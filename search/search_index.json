{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flux v2 \u00b6 Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy. Flux version 2 (\"Flux v2\") is built from the ground up to use Kubernetes' API extension system, and to integrate with Prometheus and other core components of the Kubernetes ecosystem. In version 2, Flux supports multi-tenancy and support for syncing an arbitrary number of Git repositories, among other long-requested features. Flux v2 is constructed with the GitOps Toolkit , a set of composable APIs and specialized tools for building Continuous Delivery on top of Kubernetes. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers GitOps Toolkit \u00b6 The GitOps Toolkit is the set of APIs and controllers that make up the runtime for Flux v2. The APIs comprise Kubernetes custom resources, which can be created and updated by a cluster user, or by other automation tooling. You can use the toolkit to extend Flux, or to build your own systems for continuous delivery -- see the developer guides . Components: Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Bucket CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD Get Started \u00b6 Get started with Flux v2! Following this guide will just take a couple of minutes to complete: After installing the flux CLI and running a couple of very simple commands, you will have a GitOps workflow setup which involves a staging and a production cluster. Community \u00b6 The Flux project is always looking for new contributors and there are a multitude of ways to get involved. Depending on what you want to do, some of the following bits might be your first steps: Join our upcoming dev meetings ( meeting access and agenda ) Ask questions and add suggestions in our GitOps Toolkit Discussions Talk to us in the #flux channel on CNCF Slack Join the planning discussions And if you are completely new to Flux v2 and the GitOps Toolkit, take a look at our Get Started guide and give us feedback Check out how to contribute to the project Featured Talks \u00b6 28 Oct 2020 - The Kubelist Podcast: Flux with Michael Bridgen 19 Oct 2020 - The Power of GitOps with Flux & GitOps Toolkit - Part 1 with Leigh Capili 12 Oct 2020 - Rawkode Live: Introduction to GitOps Toolkit with Stefan Prodan 4 Sep 2020 - KubeCon Europe: The road to Flux v2 and Progressive Delivery with Stefan Prodan & Hidde Beydals 25 June 2020 - Cloud Native Nordics: Introduction to GitOps & GitOps Toolkit with Alexis Richardson & Stefan Prodan 7 May 2020 - GitOps Days - Community Special: GitOps Toolkit Experimentation with Stefan Prodan Upcoming Events \u00b6 2 Nov 2020 - The Power of GitOps with Flux & GitOps Toolkit - Part 2 with Leigh Capili 12-13 Nov 2020 - GitOps Days EMEA with talks and workshops on migrating to Flux v2 and Helm Controller 19 Nov 2020 - KubeCon NA: Progressive Delivery Techniques with Flagger and Flux v2 with Stefan Prodan We are looking forward to seeing you with us!","title":"Introduction"},{"location":"#flux-v2","text":"Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy. Flux version 2 (\"Flux v2\") is built from the ground up to use Kubernetes' API extension system, and to integrate with Prometheus and other core components of the Kubernetes ecosystem. In version 2, Flux supports multi-tenancy and support for syncing an arbitrary number of Git repositories, among other long-requested features. Flux v2 is constructed with the GitOps Toolkit , a set of composable APIs and specialized tools for building Continuous Delivery on top of Kubernetes. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers","title":"Flux v2"},{"location":"#gitops-toolkit","text":"The GitOps Toolkit is the set of APIs and controllers that make up the runtime for Flux v2. The APIs comprise Kubernetes custom resources, which can be created and updated by a cluster user, or by other automation tooling. You can use the toolkit to extend Flux, or to build your own systems for continuous delivery -- see the developer guides . Components: Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Bucket CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD","title":"GitOps Toolkit"},{"location":"#get-started","text":"Get started with Flux v2! Following this guide will just take a couple of minutes to complete: After installing the flux CLI and running a couple of very simple commands, you will have a GitOps workflow setup which involves a staging and a production cluster.","title":"Get Started"},{"location":"#community","text":"The Flux project is always looking for new contributors and there are a multitude of ways to get involved. Depending on what you want to do, some of the following bits might be your first steps: Join our upcoming dev meetings ( meeting access and agenda ) Ask questions and add suggestions in our GitOps Toolkit Discussions Talk to us in the #flux channel on CNCF Slack Join the planning discussions And if you are completely new to Flux v2 and the GitOps Toolkit, take a look at our Get Started guide and give us feedback Check out how to contribute to the project","title":"Community"},{"location":"#featured-talks","text":"28 Oct 2020 - The Kubelist Podcast: Flux with Michael Bridgen 19 Oct 2020 - The Power of GitOps with Flux & GitOps Toolkit - Part 1 with Leigh Capili 12 Oct 2020 - Rawkode Live: Introduction to GitOps Toolkit with Stefan Prodan 4 Sep 2020 - KubeCon Europe: The road to Flux v2 and Progressive Delivery with Stefan Prodan & Hidde Beydals 25 June 2020 - Cloud Native Nordics: Introduction to GitOps & GitOps Toolkit with Alexis Richardson & Stefan Prodan 7 May 2020 - GitOps Days - Community Special: GitOps Toolkit Experimentation with Stefan Prodan","title":"Featured Talks"},{"location":"#upcoming-events","text":"2 Nov 2020 - The Power of GitOps with Flux & GitOps Toolkit - Part 2 with Leigh Capili 12-13 Nov 2020 - GitOps Days EMEA with talks and workshops on migrating to Flux v2 and Helm Controller 19 Nov 2020 - KubeCon NA: Progressive Delivery Techniques with Flagger and Flux v2 with Stefan Prodan We are looking forward to seeing you with us!","title":"Upcoming Events"},{"location":"cmd/flux/","text":"flux \u00b6 Command line utility for assembling Kubernetes CD pipelines Synopsis \u00b6 Command line utility for assembling Kubernetes CD pipelines the GitOps way. Examples \u00b6 # Check prerequisites flux check --pre # Install the latest version of the toolkit flux install --version=master # Create a source from a public Git repository flux create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status flux get sources git # Trigger a GitRepository source reconciliation flux reconcile source git flux-system # Export GitRepository sources in YAML format flux export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices flux create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes flux reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation flux suspend kustomization webapp-dev # Export Kustomizations in YAML format flux export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation flux resume kustomization webapp-dev # Delete a Kustomization flux delete kustomization webapp-dev # Delete a GitRepository source flux delete source git webapp-latest # Uninstall the toolkit and delete CRDs flux uninstall --crds Options \u00b6 -h, --help help for flux --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux bootstrap - Bootstrap toolkit components flux check - Check requirements and installation flux completion - Generates completion scripts for various shells flux create - Create or update sources and resources flux delete - Delete sources and resources flux export - Export resources in YAML format flux get - Get sources and resources flux install - Install the toolkit components flux reconcile - Reconcile sources and resources flux resume - Resume suspended resources flux suspend - Suspend resources flux uninstall - Uninstall the toolkit components","title":"Overview"},{"location":"cmd/flux/#flux","text":"Command line utility for assembling Kubernetes CD pipelines","title":"flux"},{"location":"cmd/flux/#synopsis","text":"Command line utility for assembling Kubernetes CD pipelines the GitOps way.","title":"Synopsis"},{"location":"cmd/flux/#examples","text":"# Check prerequisites flux check --pre # Install the latest version of the toolkit flux install --version=master # Create a source from a public Git repository flux create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status flux get sources git # Trigger a GitRepository source reconciliation flux reconcile source git flux-system # Export GitRepository sources in YAML format flux export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices flux create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes flux reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation flux suspend kustomization webapp-dev # Export Kustomizations in YAML format flux export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation flux resume kustomization webapp-dev # Delete a Kustomization flux delete kustomization webapp-dev # Delete a GitRepository source flux delete source git webapp-latest # Uninstall the toolkit and delete CRDs flux uninstall --crds","title":"Examples"},{"location":"cmd/flux/#options","text":"-h, --help help for flux --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options"},{"location":"cmd/flux/#see-also","text":"flux bootstrap - Bootstrap toolkit components flux check - Check requirements and installation flux completion - Generates completion scripts for various shells flux create - Create or update sources and resources flux delete - Delete sources and resources flux export - Export resources in YAML format flux get - Get sources and resources flux install - Install the toolkit components flux reconcile - Reconcile sources and resources flux resume - Resume suspended resources flux suspend - Suspend resources flux uninstall - Uninstall the toolkit components","title":"SEE ALSO"},{"location":"cmd/flux_bootstrap/","text":"flux bootstrap \u00b6 Bootstrap toolkit components Synopsis \u00b6 The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider. Options \u00b6 --arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level logLevel log level, available options are: (debug, info, error) (default info) --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux bootstrap github - Bootstrap toolkit components in a GitHub repository flux bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"Bootstrap"},{"location":"cmd/flux_bootstrap/#flux-bootstrap","text":"Bootstrap toolkit components","title":"flux bootstrap"},{"location":"cmd/flux_bootstrap/#synopsis","text":"The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider.","title":"Synopsis"},{"location":"cmd/flux_bootstrap/#options","text":"--arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level logLevel log level, available options are: (debug, info, error) (default info) --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options"},{"location":"cmd/flux_bootstrap/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_bootstrap/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux bootstrap github - Bootstrap toolkit components in a GitHub repository flux bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"SEE ALSO"},{"location":"cmd/flux_bootstrap_github/","text":"flux bootstrap github \u00b6 Bootstrap toolkit components in a GitHub repository Synopsis \u00b6 The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. flux bootstrap github [flags] Examples \u00b6 # Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization flux bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it flux bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path flux bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account flux bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise flux bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main flux bootstrap github --owner=<organization> --repository=<repo name> --branch=main Options \u00b6 -h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access Options inherited from parent commands \u00b6 --arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level logLevel log level, available options are: (debug, info, error) (default info) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) SEE ALSO \u00b6 flux bootstrap - Bootstrap toolkit components","title":"Bootstrap github"},{"location":"cmd/flux_bootstrap_github/#flux-bootstrap-github","text":"Bootstrap toolkit components in a GitHub repository","title":"flux bootstrap github"},{"location":"cmd/flux_bootstrap_github/#synopsis","text":"The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. flux bootstrap github [flags]","title":"Synopsis"},{"location":"cmd/flux_bootstrap_github/#examples","text":"# Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization flux bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it flux bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path flux bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account flux bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise flux bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main flux bootstrap github --owner=<organization> --repository=<repo name> --branch=main","title":"Examples"},{"location":"cmd/flux_bootstrap_github/#options","text":"-h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access","title":"Options"},{"location":"cmd/flux_bootstrap_github/#options-inherited-from-parent-commands","text":"--arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level logLevel log level, available options are: (debug, info, error) (default info) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options inherited from parent commands"},{"location":"cmd/flux_bootstrap_github/#see-also","text":"flux bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/flux_bootstrap_gitlab/","text":"flux bootstrap gitlab \u00b6 Bootstrap toolkit components in a GitLab repository Synopsis \u00b6 The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. flux bootstrap gitlab [flags] Examples \u00b6 # Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo using HTTPS token authentication flux bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a private repo using SSH authentication flux bootstrap gitlab --owner=<group> --repository=<repo name> --ssh-hostname=gitlab.com # Run bootstrap for a repository path flux bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account flux bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server flux bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main flux bootstrap gitlab --owner=<organization> --repository=<repo name> --branch=main Options \u00b6 -h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name --ssh-hostname string GitLab SSH hostname, when specified a deploy key will be added to the repository Options inherited from parent commands \u00b6 --arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level logLevel log level, available options are: (debug, info, error) (default info) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) SEE ALSO \u00b6 flux bootstrap - Bootstrap toolkit components","title":"Bootstrap gitlab"},{"location":"cmd/flux_bootstrap_gitlab/#flux-bootstrap-gitlab","text":"Bootstrap toolkit components in a GitLab repository","title":"flux bootstrap gitlab"},{"location":"cmd/flux_bootstrap_gitlab/#synopsis","text":"The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. flux bootstrap gitlab [flags]","title":"Synopsis"},{"location":"cmd/flux_bootstrap_gitlab/#examples","text":"# Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo using HTTPS token authentication flux bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a private repo using SSH authentication flux bootstrap gitlab --owner=<group> --repository=<repo name> --ssh-hostname=gitlab.com # Run bootstrap for a repository path flux bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account flux bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server flux bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main flux bootstrap gitlab --owner=<organization> --repository=<repo name> --branch=main","title":"Examples"},{"location":"cmd/flux_bootstrap_gitlab/#options","text":"-h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name --ssh-hostname string GitLab SSH hostname, when specified a deploy key will be added to the repository","title":"Options"},{"location":"cmd/flux_bootstrap_gitlab/#options-inherited-from-parent-commands","text":"--arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level logLevel log level, available options are: (debug, info, error) (default info) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options inherited from parent commands"},{"location":"cmd/flux_bootstrap_gitlab/#see-also","text":"flux bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/flux_check/","text":"flux check \u00b6 Check requirements and installation Synopsis \u00b6 The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. flux check [flags] Examples \u00b6 # Run pre-installation checks flux check --pre # Run installation checks flux check Options \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines","title":"Check"},{"location":"cmd/flux_check/#flux-check","text":"Check requirements and installation","title":"flux check"},{"location":"cmd/flux_check/#synopsis","text":"The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. flux check [flags]","title":"Synopsis"},{"location":"cmd/flux_check/#examples","text":"# Run pre-installation checks flux check --pre # Run installation checks flux check","title":"Examples"},{"location":"cmd/flux_check/#options","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks","title":"Options"},{"location":"cmd/flux_check/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_check/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/flux_completion/","text":"flux completion \u00b6 Generates completion scripts for various shells Synopsis \u00b6 The completion sub-command generates completion scripts for various shells Options \u00b6 -h, --help help for completion Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux completion bash - Generates bash completion scripts flux completion fish - Generates fish completion scripts flux completion powershell - Generates powershell completion scripts flux completion zsh - Generates zsh completion scripts","title":"Flux completion"},{"location":"cmd/flux_completion/#flux-completion","text":"Generates completion scripts for various shells","title":"flux completion"},{"location":"cmd/flux_completion/#synopsis","text":"The completion sub-command generates completion scripts for various shells","title":"Synopsis"},{"location":"cmd/flux_completion/#options","text":"-h, --help help for completion","title":"Options"},{"location":"cmd/flux_completion/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_completion/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux completion bash - Generates bash completion scripts flux completion fish - Generates fish completion scripts flux completion powershell - Generates powershell completion scripts flux completion zsh - Generates zsh completion scripts","title":"SEE ALSO"},{"location":"cmd/flux_completion_bash/","text":"flux completion bash \u00b6 Generates bash completion scripts Synopsis \u00b6 Generates bash completion scripts flux completion bash [flags] Examples \u00b6 To load completion run . <(flux completion bash) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile command -v flux >/dev/null && . <(flux completion bash) Options \u00b6 -h, --help help for bash Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux completion - Generates completion scripts for various shells","title":"Flux completion bash"},{"location":"cmd/flux_completion_bash/#flux-completion-bash","text":"Generates bash completion scripts","title":"flux completion bash"},{"location":"cmd/flux_completion_bash/#synopsis","text":"Generates bash completion scripts flux completion bash [flags]","title":"Synopsis"},{"location":"cmd/flux_completion_bash/#examples","text":"To load completion run . <(flux completion bash) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile command -v flux >/dev/null && . <(flux completion bash)","title":"Examples"},{"location":"cmd/flux_completion_bash/#options","text":"-h, --help help for bash","title":"Options"},{"location":"cmd/flux_completion_bash/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_completion_bash/#see-also","text":"flux completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/flux_completion_fish/","text":"flux completion fish \u00b6 Generates fish completion scripts Synopsis \u00b6 Generates fish completion scripts flux completion fish [flags] Examples \u00b6 To load completion run . <(flux completion fish) To configure your fish shell to load completions for each session write this script to your completions dir: flux completion fish > ~/.config/fish/completions/flux See http://fishshell.com/docs/current/index.html#completion-own for more details Options \u00b6 -h, --help help for fish Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux completion - Generates completion scripts for various shells","title":"Flux completion fish"},{"location":"cmd/flux_completion_fish/#flux-completion-fish","text":"Generates fish completion scripts","title":"flux completion fish"},{"location":"cmd/flux_completion_fish/#synopsis","text":"Generates fish completion scripts flux completion fish [flags]","title":"Synopsis"},{"location":"cmd/flux_completion_fish/#examples","text":"To load completion run . <(flux completion fish) To configure your fish shell to load completions for each session write this script to your completions dir: flux completion fish > ~/.config/fish/completions/flux See http://fishshell.com/docs/current/index.html#completion-own for more details","title":"Examples"},{"location":"cmd/flux_completion_fish/#options","text":"-h, --help help for fish","title":"Options"},{"location":"cmd/flux_completion_fish/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_completion_fish/#see-also","text":"flux completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/flux_completion_powershell/","text":"flux completion powershell \u00b6 Generates powershell completion scripts Synopsis \u00b6 Generates powershell completion scripts flux completion powershell [flags] Examples \u00b6 To load completion run . <(flux completion powershell) To configure your powershell shell to load completions for each session add to your powershell profile Windows: cd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\" flux completion >> flux-completion.ps1 Linux: cd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\" flux completion >> flux-completions.ps1 Options \u00b6 -h, --help help for powershell Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux completion - Generates completion scripts for various shells","title":"Flux completion powershell"},{"location":"cmd/flux_completion_powershell/#flux-completion-powershell","text":"Generates powershell completion scripts","title":"flux completion powershell"},{"location":"cmd/flux_completion_powershell/#synopsis","text":"Generates powershell completion scripts flux completion powershell [flags]","title":"Synopsis"},{"location":"cmd/flux_completion_powershell/#examples","text":"To load completion run . <(flux completion powershell) To configure your powershell shell to load completions for each session add to your powershell profile Windows: cd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\" flux completion >> flux-completion.ps1 Linux: cd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\" flux completion >> flux-completions.ps1","title":"Examples"},{"location":"cmd/flux_completion_powershell/#options","text":"-h, --help help for powershell","title":"Options"},{"location":"cmd/flux_completion_powershell/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_completion_powershell/#see-also","text":"flux completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/flux_completion_zsh/","text":"flux completion zsh \u00b6 Generates zsh completion scripts Synopsis \u00b6 Generates zsh completion scripts flux completion zsh [flags] Examples \u00b6 To load completion run . <(flux completion zsh) && compdef _flux flux To configure your zsh shell to load completions for each session add to your zshrc # ~/.zshrc or ~/.profile command -v flux >/dev/null && . <(flux completion zsh) && compdef _flux flux or write a cached file in one of the completion directories in your ${fpath}: echo \"${fpath// /\\n}\" | grep -i completion flux completions zsh > _flux mv _flux ~/.oh-my-zsh/completions # oh-my-zsh mv _flux ~/.zprezto/modules/completion/external/src/ # zprezto Options \u00b6 -h, --help help for zsh Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux completion - Generates completion scripts for various shells","title":"Flux completion zsh"},{"location":"cmd/flux_completion_zsh/#flux-completion-zsh","text":"Generates zsh completion scripts","title":"flux completion zsh"},{"location":"cmd/flux_completion_zsh/#synopsis","text":"Generates zsh completion scripts flux completion zsh [flags]","title":"Synopsis"},{"location":"cmd/flux_completion_zsh/#examples","text":"To load completion run . <(flux completion zsh) && compdef _flux flux To configure your zsh shell to load completions for each session add to your zshrc # ~/.zshrc or ~/.profile command -v flux >/dev/null && . <(flux completion zsh) && compdef _flux flux or write a cached file in one of the completion directories in your ${fpath}: echo \"${fpath// /\\n}\" | grep -i completion flux completions zsh > _flux mv _flux ~/.oh-my-zsh/completions # oh-my-zsh mv _flux ~/.zprezto/modules/completion/external/src/ # zprezto","title":"Examples"},{"location":"cmd/flux_completion_zsh/#options","text":"-h, --help help for zsh","title":"Options"},{"location":"cmd/flux_completion_zsh/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_completion_zsh/#see-also","text":"flux completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/flux_create/","text":"flux create \u00b6 Create or update sources and resources Synopsis \u00b6 The create sub-commands generate sources and resources. Options \u00b6 --export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s) --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux create alert - Create or update a Alert resource flux create alert-provider - Create or update a Provider resource flux create helmrelease - Create or update a HelmRelease resource flux create kustomization - Create or update a Kustomization resource flux create receiver - Create or update a Receiver resource flux create source - Create or update sources","title":"Create"},{"location":"cmd/flux_create/#flux-create","text":"Create or update sources and resources","title":"flux create"},{"location":"cmd/flux_create/#synopsis","text":"The create sub-commands generate sources and resources.","title":"Synopsis"},{"location":"cmd/flux_create/#options","text":"--export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s) --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2)","title":"Options"},{"location":"cmd/flux_create/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux create alert - Create or update a Alert resource flux create alert-provider - Create or update a Provider resource flux create helmrelease - Create or update a HelmRelease resource flux create kustomization - Create or update a Kustomization resource flux create receiver - Create or update a Receiver resource flux create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/flux_create_alert-provider/","text":"flux create alert-provider \u00b6 Create or update a Provider resource Synopsis \u00b6 The create alert-provider command generates a Provider resource. flux create alert-provider [name] [flags] Examples \u00b6 # Create a Provider for a Slack channel flux create alert-provider slack \\ --type slack \\ --channel general \\ --address https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK \\ --secret-ref webhook-url # Create a Provider for a Github repository flux create alert-provider github-podinfo \\ --type github \\ --address https://github.com/stefanprodan/podinfo \\ --secret-ref github-token Options \u00b6 --address string path to either the git repository, chat provider or webhook --channel string channel to send messages to in the case of a chat provider -h, --help help for alert-provider --secret-ref string name of secret containing authentication token --type string type of provider --username string bot username used by the provider Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources","title":"Create alert provider"},{"location":"cmd/flux_create_alert-provider/#flux-create-alert-provider","text":"Create or update a Provider resource","title":"flux create alert-provider"},{"location":"cmd/flux_create_alert-provider/#synopsis","text":"The create alert-provider command generates a Provider resource. flux create alert-provider [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_alert-provider/#examples","text":"# Create a Provider for a Slack channel flux create alert-provider slack \\ --type slack \\ --channel general \\ --address https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK \\ --secret-ref webhook-url # Create a Provider for a Github repository flux create alert-provider github-podinfo \\ --type github \\ --address https://github.com/stefanprodan/podinfo \\ --secret-ref github-token","title":"Examples"},{"location":"cmd/flux_create_alert-provider/#options","text":"--address string path to either the git repository, chat provider or webhook --channel string channel to send messages to in the case of a chat provider -h, --help help for alert-provider --secret-ref string name of secret containing authentication token --type string type of provider --username string bot username used by the provider","title":"Options"},{"location":"cmd/flux_create_alert-provider/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_alert-provider/#see-also","text":"flux create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_create_alert/","text":"flux create alert \u00b6 Create or update a Alert resource Synopsis \u00b6 The create alert command generates a Alert resource. flux create alert [name] [flags] Examples \u00b6 # Create an Alert for kustomization events flux create alert \\ --event-severity info \\ --event-source Kustomization/flux-system \\ --provider-ref slack \\ flux-system Options \u00b6 --event-severity string severity of events to send alerts for --event-source stringArray sources that should generate alerts (<kind>/<name>) -h, --help help for alert --provider-ref string reference to provider Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources","title":"Create alert"},{"location":"cmd/flux_create_alert/#flux-create-alert","text":"Create or update a Alert resource","title":"flux create alert"},{"location":"cmd/flux_create_alert/#synopsis","text":"The create alert command generates a Alert resource. flux create alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_alert/#examples","text":"# Create an Alert for kustomization events flux create alert \\ --event-severity info \\ --event-source Kustomization/flux-system \\ --provider-ref slack \\ flux-system","title":"Examples"},{"location":"cmd/flux_create_alert/#options","text":"--event-severity string severity of events to send alerts for --event-source stringArray sources that should generate alerts (<kind>/<name>) -h, --help help for alert --provider-ref string reference to provider","title":"Options"},{"location":"cmd/flux_create_alert/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_alert/#see-also","text":"flux create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_create_helmrelease/","text":"flux create helmrelease \u00b6 Create or update a HelmRelease resource Synopsis \u00b6 The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. flux create helmrelease [name] [flags] Examples \u00b6 # Create a HelmRelease with a chart from a HelmRepository source flux create hr podinfo \\ --interval=10m \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with a chart from a GitRepository source flux create hr podinfo \\ --interval=10m \\ --source=GitRepository/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with a chart from a Bucket source flux create hr podinfo \\ --interval=10m \\ --source=Bucket/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with values from a local YAML file flux create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./my-values.yaml # Create a HelmRelease with a custom release name flux create hr podinfo \\ --release-name=podinfo-dev --source=HelmRepository/podinfo \\ --chart=podinfo \\ # Create a HelmRelease targeting another namespace than the resource flux create hr podinfo \\ --target-namespace=default \\ --source=HelmRepository/podinfo \\ --chart=podinfo # Create a HelmRelease definition on disk without applying it on the cluster flux create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./values.yaml \\ --export > podinfo-release.yaml Options \u00b6 --chart string Helm chart name or path --chart-version string Helm chart version, accepts a semver range (ignored for charts from GitRepository sources) --depends-on stringArray HelmReleases that must be ready before this release can be installed, supported formats '<name>' and '<namespace>/<name>' -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '[<target-namespace>-]<HelmRelease-name>' --source helmChartSource source that contains the chart in the format '<kind>/<name>',where kind can be one of: (HelmRepository, GitRepository, Bucket) --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources","title":"Create helmrelease"},{"location":"cmd/flux_create_helmrelease/#flux-create-helmrelease","text":"Create or update a HelmRelease resource","title":"flux create helmrelease"},{"location":"cmd/flux_create_helmrelease/#synopsis","text":"The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. flux create helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_helmrelease/#examples","text":"# Create a HelmRelease with a chart from a HelmRepository source flux create hr podinfo \\ --interval=10m \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with a chart from a GitRepository source flux create hr podinfo \\ --interval=10m \\ --source=GitRepository/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with a chart from a Bucket source flux create hr podinfo \\ --interval=10m \\ --source=Bucket/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with values from a local YAML file flux create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./my-values.yaml # Create a HelmRelease with a custom release name flux create hr podinfo \\ --release-name=podinfo-dev --source=HelmRepository/podinfo \\ --chart=podinfo \\ # Create a HelmRelease targeting another namespace than the resource flux create hr podinfo \\ --target-namespace=default \\ --source=HelmRepository/podinfo \\ --chart=podinfo # Create a HelmRelease definition on disk without applying it on the cluster flux create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./values.yaml \\ --export > podinfo-release.yaml","title":"Examples"},{"location":"cmd/flux_create_helmrelease/#options","text":"--chart string Helm chart name or path --chart-version string Helm chart version, accepts a semver range (ignored for charts from GitRepository sources) --depends-on stringArray HelmReleases that must be ready before this release can be installed, supported formats '<name>' and '<namespace>/<name>' -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '[<target-namespace>-]<HelmRelease-name>' --source helmChartSource source that contains the chart in the format '<kind>/<name>',where kind can be one of: (HelmRepository, GitRepository, Bucket) --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file","title":"Options"},{"location":"cmd/flux_create_helmrelease/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_helmrelease/#see-also","text":"flux create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_create_kustomization/","text":"flux create kustomization \u00b6 Create or update a Kustomization resource Synopsis \u00b6 The kustomization source create command generates a Kustomize resource for a given source. flux create kustomization [name] [flags] Examples \u00b6 # Create a Kustomization resource from a source at a given path flux create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one flux create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that references a Bucket flux create kustomization secrets \\ --source=Bucket/secrets \\ --prune=true \\ --interval=5m Options \u00b6 --decryption-provider decryptionProvider decryption provider, available options are: (sops) --decryption-secret string set the Kubernetes secret name that contains the OpenPGP private keys used for sops decryption --depends-on stringArray Kustomization that must be ready before this Kustomization can be applied, supported formats '<name>' and '<namespace>/<name>' --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source kustomizationSource source that contains the Kubernetes manifests in the format '[<kind>/]<name>',where kind can be one of: (GitRepository, Bucket), if kind is not specified it defaults to GitRepository --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server' Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources","title":"Create kustomization"},{"location":"cmd/flux_create_kustomization/#flux-create-kustomization","text":"Create or update a Kustomization resource","title":"flux create kustomization"},{"location":"cmd/flux_create_kustomization/#synopsis","text":"The kustomization source create command generates a Kustomize resource for a given source. flux create kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_kustomization/#examples","text":"# Create a Kustomization resource from a source at a given path flux create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one flux create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that references a Bucket flux create kustomization secrets \\ --source=Bucket/secrets \\ --prune=true \\ --interval=5m","title":"Examples"},{"location":"cmd/flux_create_kustomization/#options","text":"--decryption-provider decryptionProvider decryption provider, available options are: (sops) --decryption-secret string set the Kubernetes secret name that contains the OpenPGP private keys used for sops decryption --depends-on stringArray Kustomization that must be ready before this Kustomization can be applied, supported formats '<name>' and '<namespace>/<name>' --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source kustomizationSource source that contains the Kubernetes manifests in the format '[<kind>/]<name>',where kind can be one of: (GitRepository, Bucket), if kind is not specified it defaults to GitRepository --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server'","title":"Options"},{"location":"cmd/flux_create_kustomization/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_kustomization/#see-also","text":"flux create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_create_receiver/","text":"flux create receiver \u00b6 Create or update a Receiver resource Synopsis \u00b6 The create receiver command generates a Receiver resource. flux create receiver [name] [flags] Examples \u00b6 # Create a Receiver flux create receiver github-receiver \\ --type github \\ --event ping \\ --event push \\ --secret-ref webhook-token \\ --resource GitRepository/webapp \\ --resource HelmRepository/webapp Options \u00b6 --event stringArray -h, --help help for receiver --resource stringArray --secret-ref string --type string Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources","title":"Create receiver"},{"location":"cmd/flux_create_receiver/#flux-create-receiver","text":"Create or update a Receiver resource","title":"flux create receiver"},{"location":"cmd/flux_create_receiver/#synopsis","text":"The create receiver command generates a Receiver resource. flux create receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_receiver/#examples","text":"# Create a Receiver flux create receiver github-receiver \\ --type github \\ --event ping \\ --event push \\ --secret-ref webhook-token \\ --resource GitRepository/webapp \\ --resource HelmRepository/webapp","title":"Examples"},{"location":"cmd/flux_create_receiver/#options","text":"--event stringArray -h, --help help for receiver --resource stringArray --secret-ref string --type string","title":"Options"},{"location":"cmd/flux_create_receiver/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_receiver/#see-also","text":"flux create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_create_source/","text":"flux create source \u00b6 Create or update sources Synopsis \u00b6 The create source sub-commands generate sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create - Create or update sources and resources flux create source bucket - Create or update a Bucket source flux create source git - Create or update a GitRepository source flux create source helm - Create or update a HelmRepository source","title":"Create source"},{"location":"cmd/flux_create_source/#flux-create-source","text":"Create or update sources","title":"flux create source"},{"location":"cmd/flux_create_source/#synopsis","text":"The create source sub-commands generate sources.","title":"Synopsis"},{"location":"cmd/flux_create_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/flux_create_source/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_source/#see-also","text":"flux create - Create or update sources and resources flux create source bucket - Create or update a Bucket source flux create source git - Create or update a GitRepository source flux create source helm - Create or update a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/flux_create_source_bucket/","text":"flux create source bucket \u00b6 Create or update a Bucket source Synopsis \u00b6 The create source bucket command generates a Bucket resource and waits for it to be downloaded. For Buckets with static authentication, the credentials are stored in a Kubernetes secret. flux create source bucket [name] [flags] Examples \u00b6 # Create a source from a Buckets using static authentication flux create source bucket podinfo \\ --bucket-name=podinfo \\ --endpoint=minio.minio.svc.cluster.local:9000 \\ --insecure=true \\ --access-key=myaccesskey \\ --secret-key=mysecretkey \\ --interval=10m # Create a source from an Amazon S3 Bucket using IAM authentication flux create source bucket podinfo \\ --bucket-name=podinfo \\ --provider=aws \\ --endpoint=s3.amazonaws.com \\ --region=us-east-1 \\ --interval=10m Options \u00b6 --access-key string the bucket access key --bucket-name string the bucket name --endpoint string the bucket endpoint address -h, --help help for bucket --insecure for when connecting to a non-TLS S3 HTTP endpoint --provider sourceBucketProvider the S3 compatible storage provider name, available options are: (generic, aws) (default generic) --region string the bucket region --secret-key string the bucket secret key --secret-ref string the name of an existing secret containing credentials Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create source - Create or update sources","title":"Create source bucket"},{"location":"cmd/flux_create_source_bucket/#flux-create-source-bucket","text":"Create or update a Bucket source","title":"flux create source bucket"},{"location":"cmd/flux_create_source_bucket/#synopsis","text":"The create source bucket command generates a Bucket resource and waits for it to be downloaded. For Buckets with static authentication, the credentials are stored in a Kubernetes secret. flux create source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_source_bucket/#examples","text":"# Create a source from a Buckets using static authentication flux create source bucket podinfo \\ --bucket-name=podinfo \\ --endpoint=minio.minio.svc.cluster.local:9000 \\ --insecure=true \\ --access-key=myaccesskey \\ --secret-key=mysecretkey \\ --interval=10m # Create a source from an Amazon S3 Bucket using IAM authentication flux create source bucket podinfo \\ --bucket-name=podinfo \\ --provider=aws \\ --endpoint=s3.amazonaws.com \\ --region=us-east-1 \\ --interval=10m","title":"Examples"},{"location":"cmd/flux_create_source_bucket/#options","text":"--access-key string the bucket access key --bucket-name string the bucket name --endpoint string the bucket endpoint address -h, --help help for bucket --insecure for when connecting to a non-TLS S3 HTTP endpoint --provider sourceBucketProvider the S3 compatible storage provider name, available options are: (generic, aws) (default generic) --region string the bucket region --secret-key string the bucket secret key --secret-ref string the name of an existing secret containing credentials","title":"Options"},{"location":"cmd/flux_create_source_bucket/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_source_bucket/#see-also","text":"flux create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/flux_create_source_git/","text":"flux create source git \u00b6 Create or update a GitRepository source Synopsis \u00b6 The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. flux create source git [name] [flags] Examples \u00b6 # Create a source from a public Git repository master branch flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication flux create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key flux create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password Options \u00b6 --branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --secret-ref string the name of an existing secret containing SSH or basic credentials --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create source - Create or update sources","title":"Create source git"},{"location":"cmd/flux_create_source_git/#flux-create-source-git","text":"Create or update a GitRepository source","title":"flux create source git"},{"location":"cmd/flux_create_source_git/#synopsis","text":"The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. flux create source git [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_source_git/#examples","text":"# Create a source from a public Git repository master branch flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication flux create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key flux create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication flux create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password","title":"Examples"},{"location":"cmd/flux_create_source_git/#options","text":"--branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --secret-ref string the name of an existing secret containing SSH or basic credentials --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username","title":"Options"},{"location":"cmd/flux_create_source_git/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_source_git/#see-also","text":"flux create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/flux_create_source_helm/","text":"flux create source helm \u00b6 Create or update a HelmRepository source Synopsis \u00b6 The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. flux create source helm [name] [flags] Examples \u00b6 # Create a source from a public Helm repository flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt Options \u00b6 --ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --secret-ref string the name of an existing secret containing TLS or basic auth credentials --url string Helm repository address -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux create source - Create or update sources","title":"Create source helm"},{"location":"cmd/flux_create_source_helm/#flux-create-source-helm","text":"Create or update a HelmRepository source","title":"flux create source helm"},{"location":"cmd/flux_create_source_helm/#synopsis","text":"The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. flux create source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_create_source_helm/#examples","text":"# Create a source from a public Helm repository flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication flux create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt","title":"Examples"},{"location":"cmd/flux_create_source_helm/#options","text":"--ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --secret-ref string the name of an existing secret containing TLS or basic auth credentials --url string Helm repository address -u, --username string basic authentication username","title":"Options"},{"location":"cmd/flux_create_source_helm/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_create_source_helm/#see-also","text":"flux create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/flux_delete/","text":"flux delete \u00b6 Delete sources and resources Synopsis \u00b6 The delete sub-commands delete sources and resources. Options \u00b6 -h, --help help for delete -s, --silent delete resource without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux delete alert - Delete a Alert resource flux delete alert-provider - Delete a Provider resource flux delete helmrelease - Delete a HelmRelease resource flux delete kustomization - Delete a Kustomization resource flux delete receiver - Delete a Receiver resource flux delete source - Delete sources","title":"Delete"},{"location":"cmd/flux_delete/#flux-delete","text":"Delete sources and resources","title":"flux delete"},{"location":"cmd/flux_delete/#synopsis","text":"The delete sub-commands delete sources and resources.","title":"Synopsis"},{"location":"cmd/flux_delete/#options","text":"-h, --help help for delete -s, --silent delete resource without asking for confirmation","title":"Options"},{"location":"cmd/flux_delete/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux delete alert - Delete a Alert resource flux delete alert-provider - Delete a Provider resource flux delete helmrelease - Delete a HelmRelease resource flux delete kustomization - Delete a Kustomization resource flux delete receiver - Delete a Receiver resource flux delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/flux_delete_alert-provider/","text":"flux delete alert-provider \u00b6 Delete a Provider resource Synopsis \u00b6 The delete alert-provider command removes the given Provider from the cluster. flux delete alert-provider [name] [flags] Examples \u00b6 # Delete a Provider and the Kubernetes resources created by it flux delete alert-provider slack Options \u00b6 -h, --help help for alert-provider Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources","title":"Flux delete alert provider"},{"location":"cmd/flux_delete_alert-provider/#flux-delete-alert-provider","text":"Delete a Provider resource","title":"flux delete alert-provider"},{"location":"cmd/flux_delete_alert-provider/#synopsis","text":"The delete alert-provider command removes the given Provider from the cluster. flux delete alert-provider [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_alert-provider/#examples","text":"# Delete a Provider and the Kubernetes resources created by it flux delete alert-provider slack","title":"Examples"},{"location":"cmd/flux_delete_alert-provider/#options","text":"-h, --help help for alert-provider","title":"Options"},{"location":"cmd/flux_delete_alert-provider/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_alert-provider/#see-also","text":"flux delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_delete_alert/","text":"flux delete alert \u00b6 Delete a Alert resource Synopsis \u00b6 The delete alert command removes the given Alert from the cluster. flux delete alert [name] [flags] Examples \u00b6 # Delete an Alert and the Kubernetes resources created by it flux delete alert main Options \u00b6 -h, --help help for alert Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources","title":"Flux delete alert"},{"location":"cmd/flux_delete_alert/#flux-delete-alert","text":"Delete a Alert resource","title":"flux delete alert"},{"location":"cmd/flux_delete_alert/#synopsis","text":"The delete alert command removes the given Alert from the cluster. flux delete alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_alert/#examples","text":"# Delete an Alert and the Kubernetes resources created by it flux delete alert main","title":"Examples"},{"location":"cmd/flux_delete_alert/#options","text":"-h, --help help for alert","title":"Options"},{"location":"cmd/flux_delete_alert/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_alert/#see-also","text":"flux delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_delete_helmrelease/","text":"flux delete helmrelease \u00b6 Delete a HelmRelease resource Synopsis \u00b6 The delete helmrelease command removes the given HelmRelease from the cluster. flux delete helmrelease [name] [flags] Examples \u00b6 # Delete a Helm release and the Kubernetes resources created by it flux delete hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources","title":"Delete helmrelease"},{"location":"cmd/flux_delete_helmrelease/#flux-delete-helmrelease","text":"Delete a HelmRelease resource","title":"flux delete helmrelease"},{"location":"cmd/flux_delete_helmrelease/#synopsis","text":"The delete helmrelease command removes the given HelmRelease from the cluster. flux delete helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_helmrelease/#examples","text":"# Delete a Helm release and the Kubernetes resources created by it flux delete hr podinfo","title":"Examples"},{"location":"cmd/flux_delete_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/flux_delete_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_helmrelease/#see-also","text":"flux delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_delete_kustomization/","text":"flux delete kustomization \u00b6 Delete a Kustomization resource Synopsis \u00b6 The delete kustomization command deletes the given Kustomization from the cluster. flux delete kustomization [name] [flags] Examples \u00b6 # Delete a kustomization and the Kubernetes resources created by it flux delete kustomization podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources","title":"Delete kustomization"},{"location":"cmd/flux_delete_kustomization/#flux-delete-kustomization","text":"Delete a Kustomization resource","title":"flux delete kustomization"},{"location":"cmd/flux_delete_kustomization/#synopsis","text":"The delete kustomization command deletes the given Kustomization from the cluster. flux delete kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_kustomization/#examples","text":"# Delete a kustomization and the Kubernetes resources created by it flux delete kustomization podinfo","title":"Examples"},{"location":"cmd/flux_delete_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/flux_delete_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_kustomization/#see-also","text":"flux delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_delete_receiver/","text":"flux delete receiver \u00b6 Delete a Receiver resource Synopsis \u00b6 The delete receiver command removes the given Receiver from the cluster. flux delete receiver [name] [flags] Examples \u00b6 # Delete an Receiver and the Kubernetes resources created by it flux delete receiver main Options \u00b6 -h, --help help for receiver Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources","title":"Flux delete receiver"},{"location":"cmd/flux_delete_receiver/#flux-delete-receiver","text":"Delete a Receiver resource","title":"flux delete receiver"},{"location":"cmd/flux_delete_receiver/#synopsis","text":"The delete receiver command removes the given Receiver from the cluster. flux delete receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_receiver/#examples","text":"# Delete an Receiver and the Kubernetes resources created by it flux delete receiver main","title":"Examples"},{"location":"cmd/flux_delete_receiver/#options","text":"-h, --help help for receiver","title":"Options"},{"location":"cmd/flux_delete_receiver/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_receiver/#see-also","text":"flux delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_delete_source/","text":"flux delete source \u00b6 Delete sources Synopsis \u00b6 The delete source sub-commands delete sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete - Delete sources and resources flux delete source bucket - Delete a Bucket source flux delete source git - Delete a GitRepository source flux delete source helm - Delete a HelmRepository source","title":"Delete source"},{"location":"cmd/flux_delete_source/#flux-delete-source","text":"Delete sources","title":"flux delete source"},{"location":"cmd/flux_delete_source/#synopsis","text":"The delete source sub-commands delete sources.","title":"Synopsis"},{"location":"cmd/flux_delete_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/flux_delete_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_source/#see-also","text":"flux delete - Delete sources and resources flux delete source bucket - Delete a Bucket source flux delete source git - Delete a GitRepository source flux delete source helm - Delete a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/flux_delete_source_bucket/","text":"flux delete source bucket \u00b6 Delete a Bucket source Synopsis \u00b6 The delete source bucket command deletes the given Bucket from the cluster. flux delete source bucket [name] [flags] Examples \u00b6 # Delete a Bucket source flux delete source bucket podinfo Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete source - Delete sources","title":"Delete source bucket"},{"location":"cmd/flux_delete_source_bucket/#flux-delete-source-bucket","text":"Delete a Bucket source","title":"flux delete source bucket"},{"location":"cmd/flux_delete_source_bucket/#synopsis","text":"The delete source bucket command deletes the given Bucket from the cluster. flux delete source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_source_bucket/#examples","text":"# Delete a Bucket source flux delete source bucket podinfo","title":"Examples"},{"location":"cmd/flux_delete_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/flux_delete_source_bucket/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_source_bucket/#see-also","text":"flux delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/flux_delete_source_git/","text":"flux delete source git \u00b6 Delete a GitRepository source Synopsis \u00b6 The delete source git command deletes the given GitRepository from the cluster. flux delete source git [name] [flags] Examples \u00b6 # Delete a Git repository flux delete source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete source - Delete sources","title":"Delete source git"},{"location":"cmd/flux_delete_source_git/#flux-delete-source-git","text":"Delete a GitRepository source","title":"flux delete source git"},{"location":"cmd/flux_delete_source_git/#synopsis","text":"The delete source git command deletes the given GitRepository from the cluster. flux delete source git [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_source_git/#examples","text":"# Delete a Git repository flux delete source git podinfo","title":"Examples"},{"location":"cmd/flux_delete_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/flux_delete_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_source_git/#see-also","text":"flux delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/flux_delete_source_helm/","text":"flux delete source helm \u00b6 Delete a HelmRepository source Synopsis \u00b6 The delete source helm command deletes the given HelmRepository from the cluster. flux delete source helm [name] [flags] Examples \u00b6 # Delete a Helm repository flux delete source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux delete source - Delete sources","title":"Delete source helm"},{"location":"cmd/flux_delete_source_helm/#flux-delete-source-helm","text":"Delete a HelmRepository source","title":"flux delete source helm"},{"location":"cmd/flux_delete_source_helm/#synopsis","text":"The delete source helm command deletes the given HelmRepository from the cluster. flux delete source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_delete_source_helm/#examples","text":"# Delete a Helm repository flux delete source helm podinfo","title":"Examples"},{"location":"cmd/flux_delete_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/flux_delete_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_delete_source_helm/#see-also","text":"flux delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/flux_export/","text":"flux export \u00b6 Export resources in YAML format Synopsis \u00b6 The export sub-commands export resources in YAML format. Options \u00b6 --all select all resources -h, --help help for export Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux export alert - Export Alert resources in YAML format flux export alert-provider - Export Provider resources in YAML format flux export helmrelease - Export HelmRelease resources in YAML format flux export kustomization - Export Kustomization resources in YAML format flux export receiver - Export Receiver resources in YAML format flux export source - Export sources","title":"Export"},{"location":"cmd/flux_export/#flux-export","text":"Export resources in YAML format","title":"flux export"},{"location":"cmd/flux_export/#synopsis","text":"The export sub-commands export resources in YAML format.","title":"Synopsis"},{"location":"cmd/flux_export/#options","text":"--all select all resources -h, --help help for export","title":"Options"},{"location":"cmd/flux_export/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux export alert - Export Alert resources in YAML format flux export alert-provider - Export Provider resources in YAML format flux export helmrelease - Export HelmRelease resources in YAML format flux export kustomization - Export Kustomization resources in YAML format flux export receiver - Export Receiver resources in YAML format flux export source - Export sources","title":"SEE ALSO"},{"location":"cmd/flux_export_alert-provider/","text":"flux export alert-provider \u00b6 Export Provider resources in YAML format Synopsis \u00b6 The export alert-provider command exports one or all Provider resources in YAML format. flux export alert-provider [name] [flags] Examples \u00b6 # Export all Provider resources flux export alert-provider --all > alert-providers.yaml # Export a Provider flux export alert-provider slack > slack.yaml Options \u00b6 -h, --help help for alert-provider Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format","title":"Export alert provider"},{"location":"cmd/flux_export_alert-provider/#flux-export-alert-provider","text":"Export Provider resources in YAML format","title":"flux export alert-provider"},{"location":"cmd/flux_export_alert-provider/#synopsis","text":"The export alert-provider command exports one or all Provider resources in YAML format. flux export alert-provider [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_alert-provider/#examples","text":"# Export all Provider resources flux export alert-provider --all > alert-providers.yaml # Export a Provider flux export alert-provider slack > slack.yaml","title":"Examples"},{"location":"cmd/flux_export_alert-provider/#options","text":"-h, --help help for alert-provider","title":"Options"},{"location":"cmd/flux_export_alert-provider/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_alert-provider/#see-also","text":"flux export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_alert/","text":"flux export alert \u00b6 Export Alert resources in YAML format Synopsis \u00b6 The export alert command exports one or all Alert resources in YAML format. flux export alert [name] [flags] Examples \u00b6 # Export all Alert resources flux export alert --all > alerts.yaml # Export a Alert flux export alert main > main.yaml Options \u00b6 -h, --help help for alert Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format","title":"Export alert"},{"location":"cmd/flux_export_alert/#flux-export-alert","text":"Export Alert resources in YAML format","title":"flux export alert"},{"location":"cmd/flux_export_alert/#synopsis","text":"The export alert command exports one or all Alert resources in YAML format. flux export alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_alert/#examples","text":"# Export all Alert resources flux export alert --all > alerts.yaml # Export a Alert flux export alert main > main.yaml","title":"Examples"},{"location":"cmd/flux_export_alert/#options","text":"-h, --help help for alert","title":"Options"},{"location":"cmd/flux_export_alert/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_alert/#see-also","text":"flux export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_helmrelease/","text":"flux export helmrelease \u00b6 Export HelmRelease resources in YAML format Synopsis \u00b6 The export helmrelease command exports one or all HelmRelease resources in YAML format. flux export helmrelease [name] [flags] Examples \u00b6 # Export all HelmRelease resources flux export helmrelease --all > kustomizations.yaml # Export a HelmRelease flux export hr my-app > app-release.yaml Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format","title":"Export helmrelease"},{"location":"cmd/flux_export_helmrelease/#flux-export-helmrelease","text":"Export HelmRelease resources in YAML format","title":"flux export helmrelease"},{"location":"cmd/flux_export_helmrelease/#synopsis","text":"The export helmrelease command exports one or all HelmRelease resources in YAML format. flux export helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_helmrelease/#examples","text":"# Export all HelmRelease resources flux export helmrelease --all > kustomizations.yaml # Export a HelmRelease flux export hr my-app > app-release.yaml","title":"Examples"},{"location":"cmd/flux_export_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/flux_export_helmrelease/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_helmrelease/#see-also","text":"flux export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_kustomization/","text":"flux export kustomization \u00b6 Export Kustomization resources in YAML format Synopsis \u00b6 The export kustomization command exports one or all Kustomization resources in YAML format. flux export kustomization [name] [flags] Examples \u00b6 # Export all Kustomization resources flux export kustomization --all > kustomizations.yaml # Export a Kustomization flux export kustomization my-app > kustomization.yaml Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format","title":"Export kustomization"},{"location":"cmd/flux_export_kustomization/#flux-export-kustomization","text":"Export Kustomization resources in YAML format","title":"flux export kustomization"},{"location":"cmd/flux_export_kustomization/#synopsis","text":"The export kustomization command exports one or all Kustomization resources in YAML format. flux export kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_kustomization/#examples","text":"# Export all Kustomization resources flux export kustomization --all > kustomizations.yaml # Export a Kustomization flux export kustomization my-app > kustomization.yaml","title":"Examples"},{"location":"cmd/flux_export_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/flux_export_kustomization/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_kustomization/#see-also","text":"flux export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_receiver/","text":"flux export receiver \u00b6 Export Receiver resources in YAML format Synopsis \u00b6 The export receiver command exports one or all Receiver resources in YAML format. flux export receiver [name] [flags] Examples \u00b6 # Export all Receiver resources flux export receiver --all > receivers.yaml # Export a Receiver flux export receiver main > main.yaml Options \u00b6 -h, --help help for receiver Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format","title":"Export receiver"},{"location":"cmd/flux_export_receiver/#flux-export-receiver","text":"Export Receiver resources in YAML format","title":"flux export receiver"},{"location":"cmd/flux_export_receiver/#synopsis","text":"The export receiver command exports one or all Receiver resources in YAML format. flux export receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_receiver/#examples","text":"# Export all Receiver resources flux export receiver --all > receivers.yaml # Export a Receiver flux export receiver main > main.yaml","title":"Examples"},{"location":"cmd/flux_export_receiver/#options","text":"-h, --help help for receiver","title":"Options"},{"location":"cmd/flux_export_receiver/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_receiver/#see-also","text":"flux export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_source/","text":"flux export source \u00b6 Export sources Synopsis \u00b6 The export source sub-commands export sources in YAML format. Options \u00b6 -h, --help help for source --with-credentials include credential secrets Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux export - Export resources in YAML format flux export source bucket - Export Bucket sources in YAML format flux export source git - Export GitRepository sources in YAML format flux export source helm - Export HelmRepository sources in YAML format","title":"Export source"},{"location":"cmd/flux_export_source/#flux-export-source","text":"Export sources","title":"flux export source"},{"location":"cmd/flux_export_source/#synopsis","text":"The export source sub-commands export sources in YAML format.","title":"Synopsis"},{"location":"cmd/flux_export_source/#options","text":"-h, --help help for source --with-credentials include credential secrets","title":"Options"},{"location":"cmd/flux_export_source/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_source/#see-also","text":"flux export - Export resources in YAML format flux export source bucket - Export Bucket sources in YAML format flux export source git - Export GitRepository sources in YAML format flux export source helm - Export HelmRepository sources in YAML format","title":"SEE ALSO"},{"location":"cmd/flux_export_source_bucket/","text":"flux export source bucket \u00b6 Export Bucket sources in YAML format Synopsis \u00b6 The export source git command exports on or all Bucket sources in YAML format. flux export source bucket [name] [flags] Examples \u00b6 # Export all Bucket sources flux export source bucket --all > sources.yaml # Export a Bucket source including the static credentials flux export source bucket my-bucket --with-credentials > source.yaml Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 flux export source - Export sources","title":"Export source bucket"},{"location":"cmd/flux_export_source_bucket/#flux-export-source-bucket","text":"Export Bucket sources in YAML format","title":"flux export source bucket"},{"location":"cmd/flux_export_source_bucket/#synopsis","text":"The export source git command exports on or all Bucket sources in YAML format. flux export source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_source_bucket/#examples","text":"# Export all Bucket sources flux export source bucket --all > sources.yaml # Export a Bucket source including the static credentials flux export source bucket my-bucket --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/flux_export_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/flux_export_source_bucket/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_source_bucket/#see-also","text":"flux export source - Export sources","title":"SEE ALSO"},{"location":"cmd/flux_export_source_git/","text":"flux export source git \u00b6 Export GitRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all GitRepository sources in YAML format. flux export source git [name] [flags] Examples \u00b6 # Export all GitRepository sources flux export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials flux export source git my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 flux export source - Export sources","title":"Export source git"},{"location":"cmd/flux_export_source_git/#flux-export-source-git","text":"Export GitRepository sources in YAML format","title":"flux export source git"},{"location":"cmd/flux_export_source_git/#synopsis","text":"The export source git command exports on or all GitRepository sources in YAML format. flux export source git [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_source_git/#examples","text":"# Export all GitRepository sources flux export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials flux export source git my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/flux_export_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/flux_export_source_git/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_source_git/#see-also","text":"flux export source - Export sources","title":"SEE ALSO"},{"location":"cmd/flux_export_source_helm/","text":"flux export source helm \u00b6 Export HelmRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all HelmRepository sources in YAML format. flux export source helm [name] [flags] Examples \u00b6 # Export all HelmRepository sources flux export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials flux export source helm my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 flux export source - Export sources","title":"Export source helm"},{"location":"cmd/flux_export_source_helm/#flux-export-source-helm","text":"Export HelmRepository sources in YAML format","title":"flux export source helm"},{"location":"cmd/flux_export_source_helm/#synopsis","text":"The export source git command exports on or all HelmRepository sources in YAML format. flux export source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_export_source_helm/#examples","text":"# Export all HelmRepository sources flux export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials flux export source helm my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/flux_export_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/flux_export_source_helm/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/flux_export_source_helm/#see-also","text":"flux export source - Export sources","title":"SEE ALSO"},{"location":"cmd/flux_get/","text":"flux get \u00b6 Get sources and resources Synopsis \u00b6 The get sub-commands print the statuses of sources and resources. Options \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces -h, --help help for get Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux get alert-providers - Get Provider statuses flux get alerts - Get Alert statuses flux get helmreleases - Get HelmRelease statuses flux get kustomizations - Get Kustomization statuses flux get receivers - Get Receiver statuses flux get sources - Get source statuses","title":"Get"},{"location":"cmd/flux_get/#flux-get","text":"Get sources and resources","title":"flux get"},{"location":"cmd/flux_get/#synopsis","text":"The get sub-commands print the statuses of sources and resources.","title":"Synopsis"},{"location":"cmd/flux_get/#options","text":"-A, --all-namespaces list the requested object(s) across all namespaces -h, --help help for get","title":"Options"},{"location":"cmd/flux_get/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux get alert-providers - Get Provider statuses flux get alerts - Get Alert statuses flux get helmreleases - Get HelmRelease statuses flux get kustomizations - Get Kustomization statuses flux get receivers - Get Receiver statuses flux get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/flux_get_alert-providers/","text":"flux get alert-providers \u00b6 Get Provider statuses Synopsis \u00b6 The get alert-provider command prints the statuses of the resources. flux get alert-providers [flags] Examples \u00b6 # List all Providers and their status flux get alert-providers Options \u00b6 -h, --help help for alert-providers Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources","title":"Flux get alert providers"},{"location":"cmd/flux_get_alert-providers/#flux-get-alert-providers","text":"Get Provider statuses","title":"flux get alert-providers"},{"location":"cmd/flux_get_alert-providers/#synopsis","text":"The get alert-provider command prints the statuses of the resources. flux get alert-providers [flags]","title":"Synopsis"},{"location":"cmd/flux_get_alert-providers/#examples","text":"# List all Providers and their status flux get alert-providers","title":"Examples"},{"location":"cmd/flux_get_alert-providers/#options","text":"-h, --help help for alert-providers","title":"Options"},{"location":"cmd/flux_get_alert-providers/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_alert-providers/#see-also","text":"flux get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_get_alerts/","text":"flux get alerts \u00b6 Get Alert statuses Synopsis \u00b6 The get alert command prints the statuses of the resources. flux get alerts [flags] Examples \u00b6 # List all Alerts and their status flux get alerts Options \u00b6 -h, --help help for alerts Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources","title":"Flux get alerts"},{"location":"cmd/flux_get_alerts/#flux-get-alerts","text":"Get Alert statuses","title":"flux get alerts"},{"location":"cmd/flux_get_alerts/#synopsis","text":"The get alert command prints the statuses of the resources. flux get alerts [flags]","title":"Synopsis"},{"location":"cmd/flux_get_alerts/#examples","text":"# List all Alerts and their status flux get alerts","title":"Examples"},{"location":"cmd/flux_get_alerts/#options","text":"-h, --help help for alerts","title":"Options"},{"location":"cmd/flux_get_alerts/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_alerts/#see-also","text":"flux get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_get_helmreleases/","text":"flux get helmreleases \u00b6 Get HelmRelease statuses Synopsis \u00b6 The get helmreleases command prints the statuses of the resources. flux get helmreleases [flags] Examples \u00b6 # List all Helm releases and their status flux get helmreleases Options \u00b6 -h, --help help for helmreleases Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources","title":"Get helmreleases"},{"location":"cmd/flux_get_helmreleases/#flux-get-helmreleases","text":"Get HelmRelease statuses","title":"flux get helmreleases"},{"location":"cmd/flux_get_helmreleases/#synopsis","text":"The get helmreleases command prints the statuses of the resources. flux get helmreleases [flags]","title":"Synopsis"},{"location":"cmd/flux_get_helmreleases/#examples","text":"# List all Helm releases and their status flux get helmreleases","title":"Examples"},{"location":"cmd/flux_get_helmreleases/#options","text":"-h, --help help for helmreleases","title":"Options"},{"location":"cmd/flux_get_helmreleases/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_helmreleases/#see-also","text":"flux get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_get_kustomizations/","text":"flux get kustomizations \u00b6 Get Kustomization statuses Synopsis \u00b6 The get kustomizations command prints the statuses of the resources. flux get kustomizations [flags] Examples \u00b6 # List all kustomizations and their status flux get kustomizations Options \u00b6 -h, --help help for kustomizations Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources","title":"Get kustomizations"},{"location":"cmd/flux_get_kustomizations/#flux-get-kustomizations","text":"Get Kustomization statuses","title":"flux get kustomizations"},{"location":"cmd/flux_get_kustomizations/#synopsis","text":"The get kustomizations command prints the statuses of the resources. flux get kustomizations [flags]","title":"Synopsis"},{"location":"cmd/flux_get_kustomizations/#examples","text":"# List all kustomizations and their status flux get kustomizations","title":"Examples"},{"location":"cmd/flux_get_kustomizations/#options","text":"-h, --help help for kustomizations","title":"Options"},{"location":"cmd/flux_get_kustomizations/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_kustomizations/#see-also","text":"flux get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_get_receivers/","text":"flux get receivers \u00b6 Get Receiver statuses Synopsis \u00b6 The get receiver command prints the statuses of the resources. flux get receivers [flags] Examples \u00b6 # List all Receiver and their status flux get receivers Options \u00b6 -h, --help help for receivers Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources","title":"Flux get receivers"},{"location":"cmd/flux_get_receivers/#flux-get-receivers","text":"Get Receiver statuses","title":"flux get receivers"},{"location":"cmd/flux_get_receivers/#synopsis","text":"The get receiver command prints the statuses of the resources. flux get receivers [flags]","title":"Synopsis"},{"location":"cmd/flux_get_receivers/#examples","text":"# List all Receiver and their status flux get receivers","title":"Examples"},{"location":"cmd/flux_get_receivers/#options","text":"-h, --help help for receivers","title":"Options"},{"location":"cmd/flux_get_receivers/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_receivers/#see-also","text":"flux get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_get_sources/","text":"flux get sources \u00b6 Get source statuses Synopsis \u00b6 The get source sub-commands print the statuses of the sources. Options \u00b6 -h, --help help for sources Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get - Get sources and resources flux get sources bucket - Get Bucket source statuses flux get sources git - Get GitRepository source statuses flux get sources helm - Get HelmRepository source statuses","title":"Get sources"},{"location":"cmd/flux_get_sources/#flux-get-sources","text":"Get source statuses","title":"flux get sources"},{"location":"cmd/flux_get_sources/#synopsis","text":"The get source sub-commands print the statuses of the sources.","title":"Synopsis"},{"location":"cmd/flux_get_sources/#options","text":"-h, --help help for sources","title":"Options"},{"location":"cmd/flux_get_sources/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_sources/#see-also","text":"flux get - Get sources and resources flux get sources bucket - Get Bucket source statuses flux get sources git - Get GitRepository source statuses flux get sources helm - Get HelmRepository source statuses","title":"SEE ALSO"},{"location":"cmd/flux_get_sources_bucket/","text":"flux get sources bucket \u00b6 Get Bucket source statuses Synopsis \u00b6 The get sources bucket command prints the status of the Bucket sources. flux get sources bucket [flags] Examples \u00b6 # List all Buckets and their status flux get sources bucket Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get sources - Get source statuses","title":"Get sources bucket"},{"location":"cmd/flux_get_sources_bucket/#flux-get-sources-bucket","text":"Get Bucket source statuses","title":"flux get sources bucket"},{"location":"cmd/flux_get_sources_bucket/#synopsis","text":"The get sources bucket command prints the status of the Bucket sources. flux get sources bucket [flags]","title":"Synopsis"},{"location":"cmd/flux_get_sources_bucket/#examples","text":"# List all Buckets and their status flux get sources bucket","title":"Examples"},{"location":"cmd/flux_get_sources_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/flux_get_sources_bucket/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_sources_bucket/#see-also","text":"flux get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/flux_get_sources_git/","text":"flux get sources git \u00b6 Get GitRepository source statuses Synopsis \u00b6 The get sources git command prints the status of the GitRepository sources. flux get sources git [flags] Examples \u00b6 # List all Git repositories and their status flux get sources git Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get sources - Get source statuses","title":"Get sources git"},{"location":"cmd/flux_get_sources_git/#flux-get-sources-git","text":"Get GitRepository source statuses","title":"flux get sources git"},{"location":"cmd/flux_get_sources_git/#synopsis","text":"The get sources git command prints the status of the GitRepository sources. flux get sources git [flags]","title":"Synopsis"},{"location":"cmd/flux_get_sources_git/#examples","text":"# List all Git repositories and their status flux get sources git","title":"Examples"},{"location":"cmd/flux_get_sources_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/flux_get_sources_git/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_sources_git/#see-also","text":"flux get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/flux_get_sources_helm/","text":"flux get sources helm \u00b6 Get HelmRepository source statuses Synopsis \u00b6 The get sources helm command prints the status of the HelmRepository sources. flux get sources helm [flags] Examples \u00b6 # List all Helm repositories and their status flux get sources helm Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 -A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux get sources - Get source statuses","title":"Get sources helm"},{"location":"cmd/flux_get_sources_helm/#flux-get-sources-helm","text":"Get HelmRepository source statuses","title":"flux get sources helm"},{"location":"cmd/flux_get_sources_helm/#synopsis","text":"The get sources helm command prints the status of the HelmRepository sources. flux get sources helm [flags]","title":"Synopsis"},{"location":"cmd/flux_get_sources_helm/#examples","text":"# List all Helm repositories and their status flux get sources helm","title":"Examples"},{"location":"cmd/flux_get_sources_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/flux_get_sources_helm/#options-inherited-from-parent-commands","text":"-A, --all-namespaces list the requested object(s) across all namespaces --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_get_sources_helm/#see-also","text":"flux get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/flux_install/","text":"flux install \u00b6 Install the toolkit components Synopsis \u00b6 The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. flux install [flags] Examples \u00b6 # Install the latest version in the flux-system namespace flux install --version=latest --namespace=flux-system # Dry-run install for a specific version and a series of components flux install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview flux install --dry-run --verbose # Write install manifests to file flux install --export > flux-system.yaml Options \u00b6 --arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level logLevel log level, available options are: (debug, info, error) (default info) --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines","title":"Install"},{"location":"cmd/flux_install/#flux-install","text":"Install the toolkit components","title":"flux install"},{"location":"cmd/flux_install/#synopsis","text":"The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. flux install [flags]","title":"Synopsis"},{"location":"cmd/flux_install/#examples","text":"# Install the latest version in the flux-system namespace flux install --version=latest --namespace=flux-system # Dry-run install for a specific version and a series of components flux install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview flux install --dry-run --verbose # Write install manifests to file flux install --export > flux-system.yaml","title":"Examples"},{"location":"cmd/flux_install/#options","text":"--arch arch cluster architecture, available options are: (amd64, arm, arm64) (default amd64) --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level logLevel log level, available options are: (debug, info, error) (default info) --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options"},{"location":"cmd/flux_install/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_install/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/flux_reconcile/","text":"flux reconcile \u00b6 Reconcile sources and resources Synopsis \u00b6 The reconcile sub-commands trigger a reconciliation of sources and resources. Options \u00b6 -h, --help help for reconcile Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux reconcile alert - Reconcile an Alert flux reconcile alert-provider - Reconcile a Provider flux reconcile helmrelease - Reconcile a HelmRelease resource flux reconcile kustomization - Reconcile a Kustomization resource flux reconcile receiver - Reconcile a Receiver flux reconcile source - Reconcile sources","title":"Reconcile"},{"location":"cmd/flux_reconcile/#flux-reconcile","text":"Reconcile sources and resources","title":"flux reconcile"},{"location":"cmd/flux_reconcile/#synopsis","text":"The reconcile sub-commands trigger a reconciliation of sources and resources.","title":"Synopsis"},{"location":"cmd/flux_reconcile/#options","text":"-h, --help help for reconcile","title":"Options"},{"location":"cmd/flux_reconcile/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux reconcile alert - Reconcile an Alert flux reconcile alert-provider - Reconcile a Provider flux reconcile helmrelease - Reconcile a HelmRelease resource flux reconcile kustomization - Reconcile a Kustomization resource flux reconcile receiver - Reconcile a Receiver flux reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_alert-provider/","text":"flux reconcile alert-provider \u00b6 Reconcile a Provider Synopsis \u00b6 The reconcile alert-provider command triggers a reconciliation of a Provider resource and waits for it to finish. flux reconcile alert-provider [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing provider flux reconcile alert-provider slack Options \u00b6 -h, --help help for alert-provider Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources","title":"Flux reconcile alert provider"},{"location":"cmd/flux_reconcile_alert-provider/#flux-reconcile-alert-provider","text":"Reconcile a Provider","title":"flux reconcile alert-provider"},{"location":"cmd/flux_reconcile_alert-provider/#synopsis","text":"The reconcile alert-provider command triggers a reconciliation of a Provider resource and waits for it to finish. flux reconcile alert-provider [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_alert-provider/#examples","text":"# Trigger a reconciliation for an existing provider flux reconcile alert-provider slack","title":"Examples"},{"location":"cmd/flux_reconcile_alert-provider/#options","text":"-h, --help help for alert-provider","title":"Options"},{"location":"cmd/flux_reconcile_alert-provider/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_alert-provider/#see-also","text":"flux reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_alert/","text":"flux reconcile alert \u00b6 Reconcile an Alert Synopsis \u00b6 The reconcile alert command triggers a reconciliation of an Alert resource and waits for it to finish. flux reconcile alert [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing alert flux reconcile alert main Options \u00b6 -h, --help help for alert Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources","title":"Flux reconcile alert"},{"location":"cmd/flux_reconcile_alert/#flux-reconcile-alert","text":"Reconcile an Alert","title":"flux reconcile alert"},{"location":"cmd/flux_reconcile_alert/#synopsis","text":"The reconcile alert command triggers a reconciliation of an Alert resource and waits for it to finish. flux reconcile alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_alert/#examples","text":"# Trigger a reconciliation for an existing alert flux reconcile alert main","title":"Examples"},{"location":"cmd/flux_reconcile_alert/#options","text":"-h, --help help for alert","title":"Options"},{"location":"cmd/flux_reconcile_alert/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_alert/#see-also","text":"flux reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_helmrelease/","text":"flux reconcile helmrelease \u00b6 Reconcile a HelmRelease resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. flux reconcile helmrelease [name] [flags] Examples \u00b6 # Trigger a HelmRelease apply outside of the reconciliation interval flux reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes flux reconcile hr podinfo --with-source Options \u00b6 -h, --help help for helmrelease --with-source reconcile HelmRelease source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources","title":"Reconcile helmrelease"},{"location":"cmd/flux_reconcile_helmrelease/#flux-reconcile-helmrelease","text":"Reconcile a HelmRelease resource","title":"flux reconcile helmrelease"},{"location":"cmd/flux_reconcile_helmrelease/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. flux reconcile helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_helmrelease/#examples","text":"# Trigger a HelmRelease apply outside of the reconciliation interval flux reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes flux reconcile hr podinfo --with-source","title":"Examples"},{"location":"cmd/flux_reconcile_helmrelease/#options","text":"-h, --help help for helmrelease --with-source reconcile HelmRelease source","title":"Options"},{"location":"cmd/flux_reconcile_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_helmrelease/#see-also","text":"flux reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_kustomization/","text":"flux reconcile kustomization \u00b6 Reconcile a Kustomization resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. flux reconcile kustomization [name] [flags] Examples \u00b6 # Trigger a Kustomization apply outside of the reconciliation interval flux reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes flux reconcile kustomization podinfo --with-source Options \u00b6 -h, --help help for kustomization --with-source reconcile Kustomization source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources","title":"Reconcile kustomization"},{"location":"cmd/flux_reconcile_kustomization/#flux-reconcile-kustomization","text":"Reconcile a Kustomization resource","title":"flux reconcile kustomization"},{"location":"cmd/flux_reconcile_kustomization/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. flux reconcile kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_kustomization/#examples","text":"# Trigger a Kustomization apply outside of the reconciliation interval flux reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes flux reconcile kustomization podinfo --with-source","title":"Examples"},{"location":"cmd/flux_reconcile_kustomization/#options","text":"-h, --help help for kustomization --with-source reconcile Kustomization source","title":"Options"},{"location":"cmd/flux_reconcile_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_kustomization/#see-also","text":"flux reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_receiver/","text":"flux reconcile receiver \u00b6 Reconcile a Receiver Synopsis \u00b6 The reconcile receiver command triggers a reconciliation of a Receiver resource and waits for it to finish. flux reconcile receiver [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing receiver flux reconcile receiver main Options \u00b6 -h, --help help for receiver Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources","title":"Flux reconcile receiver"},{"location":"cmd/flux_reconcile_receiver/#flux-reconcile-receiver","text":"Reconcile a Receiver","title":"flux reconcile receiver"},{"location":"cmd/flux_reconcile_receiver/#synopsis","text":"The reconcile receiver command triggers a reconciliation of a Receiver resource and waits for it to finish. flux reconcile receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_receiver/#examples","text":"# Trigger a reconciliation for an existing receiver flux reconcile receiver main","title":"Examples"},{"location":"cmd/flux_reconcile_receiver/#options","text":"-h, --help help for receiver","title":"Options"},{"location":"cmd/flux_reconcile_receiver/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_receiver/#see-also","text":"flux reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_source/","text":"flux reconcile source \u00b6 Reconcile sources Synopsis \u00b6 The reconcile source sub-commands trigger a reconciliation of sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile - Reconcile sources and resources flux reconcile source bucket - Reconcile a Bucket source flux reconcile source git - Reconcile a GitRepository source flux reconcile source helm - Reconcile a HelmRepository source","title":"Reconcile source"},{"location":"cmd/flux_reconcile_source/#flux-reconcile-source","text":"Reconcile sources","title":"flux reconcile source"},{"location":"cmd/flux_reconcile_source/#synopsis","text":"The reconcile source sub-commands trigger a reconciliation of sources.","title":"Synopsis"},{"location":"cmd/flux_reconcile_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/flux_reconcile_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_source/#see-also","text":"flux reconcile - Reconcile sources and resources flux reconcile source bucket - Reconcile a Bucket source flux reconcile source git - Reconcile a GitRepository source flux reconcile source helm - Reconcile a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_source_bucket/","text":"flux reconcile source bucket \u00b6 Reconcile a Bucket source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a Bucket resource and waits for it to finish. flux reconcile source bucket [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing source flux reconcile source bucket podinfo Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile source - Reconcile sources","title":"Reconcile source bucket"},{"location":"cmd/flux_reconcile_source_bucket/#flux-reconcile-source-bucket","text":"Reconcile a Bucket source","title":"flux reconcile source bucket"},{"location":"cmd/flux_reconcile_source_bucket/#synopsis","text":"The reconcile source command triggers a reconciliation of a Bucket resource and waits for it to finish. flux reconcile source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_source_bucket/#examples","text":"# Trigger a reconciliation for an existing source flux reconcile source bucket podinfo","title":"Examples"},{"location":"cmd/flux_reconcile_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/flux_reconcile_source_bucket/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_source_bucket/#see-also","text":"flux reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_source_git/","text":"flux reconcile source git \u00b6 Reconcile a GitRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. flux reconcile source git [name] [flags] Examples \u00b6 # Trigger a git pull for an existing source flux reconcile source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile source - Reconcile sources","title":"Reconcile source git"},{"location":"cmd/flux_reconcile_source_git/#flux-reconcile-source-git","text":"Reconcile a GitRepository source","title":"flux reconcile source git"},{"location":"cmd/flux_reconcile_source_git/#synopsis","text":"The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. flux reconcile source git [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_source_git/#examples","text":"# Trigger a git pull for an existing source flux reconcile source git podinfo","title":"Examples"},{"location":"cmd/flux_reconcile_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/flux_reconcile_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_source_git/#see-also","text":"flux reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/flux_reconcile_source_helm/","text":"flux reconcile source helm \u00b6 Reconcile a HelmRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. flux reconcile source helm [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing source flux reconcile source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux reconcile source - Reconcile sources","title":"Reconcile source helm"},{"location":"cmd/flux_reconcile_source_helm/#flux-reconcile-source-helm","text":"Reconcile a HelmRepository source","title":"flux reconcile source helm"},{"location":"cmd/flux_reconcile_source_helm/#synopsis","text":"The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. flux reconcile source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_reconcile_source_helm/#examples","text":"# Trigger a reconciliation for an existing source flux reconcile source helm podinfo","title":"Examples"},{"location":"cmd/flux_reconcile_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/flux_reconcile_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_reconcile_source_helm/#see-also","text":"flux reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/flux_resume/","text":"flux resume \u00b6 Resume suspended resources Synopsis \u00b6 The resume sub-commands resume a suspended resource. Options \u00b6 -h, --help help for resume Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux resume alert - Resume a suspended Alert flux resume helmrelease - Resume a suspended HelmRelease flux resume kustomization - Resume a suspended Kustomization flux resume receiver - Resume a suspended Receiver","title":"Resume"},{"location":"cmd/flux_resume/#flux-resume","text":"Resume suspended resources","title":"flux resume"},{"location":"cmd/flux_resume/#synopsis","text":"The resume sub-commands resume a suspended resource.","title":"Synopsis"},{"location":"cmd/flux_resume/#options","text":"-h, --help help for resume","title":"Options"},{"location":"cmd/flux_resume/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_resume/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux resume alert - Resume a suspended Alert flux resume helmrelease - Resume a suspended HelmRelease flux resume kustomization - Resume a suspended Kustomization flux resume receiver - Resume a suspended Receiver","title":"SEE ALSO"},{"location":"cmd/flux_resume_alert/","text":"flux resume alert \u00b6 Resume a suspended Alert Synopsis \u00b6 The resume command marks a previously suspended Alert resource for reconciliation and waits for it to finish the apply. flux resume alert [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Alert flux resume alert main Options \u00b6 -h, --help help for alert Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux resume - Resume suspended resources","title":"Resume alert"},{"location":"cmd/flux_resume_alert/#flux-resume-alert","text":"Resume a suspended Alert","title":"flux resume alert"},{"location":"cmd/flux_resume_alert/#synopsis","text":"The resume command marks a previously suspended Alert resource for reconciliation and waits for it to finish the apply. flux resume alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_resume_alert/#examples","text":"# Resume reconciliation for an existing Alert flux resume alert main","title":"Examples"},{"location":"cmd/flux_resume_alert/#options","text":"-h, --help help for alert","title":"Options"},{"location":"cmd/flux_resume_alert/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_resume_alert/#see-also","text":"flux resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/flux_resume_helmrelease/","text":"flux resume helmrelease \u00b6 Resume a suspended HelmRelease Synopsis \u00b6 The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. flux resume helmrelease [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Helm release flux resume hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux resume - Resume suspended resources","title":"Resume helmrelease"},{"location":"cmd/flux_resume_helmrelease/#flux-resume-helmrelease","text":"Resume a suspended HelmRelease","title":"flux resume helmrelease"},{"location":"cmd/flux_resume_helmrelease/#synopsis","text":"The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. flux resume helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_resume_helmrelease/#examples","text":"# Resume reconciliation for an existing Helm release flux resume hr podinfo","title":"Examples"},{"location":"cmd/flux_resume_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/flux_resume_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_resume_helmrelease/#see-also","text":"flux resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/flux_resume_kustomization/","text":"flux resume kustomization \u00b6 Resume a suspended Kustomization Synopsis \u00b6 The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. flux resume kustomization [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Kustomization flux resume ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux resume - Resume suspended resources","title":"Resume kustomization"},{"location":"cmd/flux_resume_kustomization/#flux-resume-kustomization","text":"Resume a suspended Kustomization","title":"flux resume kustomization"},{"location":"cmd/flux_resume_kustomization/#synopsis","text":"The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. flux resume kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_resume_kustomization/#examples","text":"# Resume reconciliation for an existing Kustomization flux resume ks podinfo","title":"Examples"},{"location":"cmd/flux_resume_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/flux_resume_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_resume_kustomization/#see-also","text":"flux resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/flux_resume_receiver/","text":"flux resume receiver \u00b6 Resume a suspended Receiver Synopsis \u00b6 The resume command marks a previously suspended Receiver resource for reconciliation and waits for it to finish the apply. flux resume receiver [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Receiver flux resume receiver main Options \u00b6 -h, --help help for receiver Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux resume - Resume suspended resources","title":"Resume receiver"},{"location":"cmd/flux_resume_receiver/#flux-resume-receiver","text":"Resume a suspended Receiver","title":"flux resume receiver"},{"location":"cmd/flux_resume_receiver/#synopsis","text":"The resume command marks a previously suspended Receiver resource for reconciliation and waits for it to finish the apply. flux resume receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_resume_receiver/#examples","text":"# Resume reconciliation for an existing Receiver flux resume receiver main","title":"Examples"},{"location":"cmd/flux_resume_receiver/#options","text":"-h, --help help for receiver","title":"Options"},{"location":"cmd/flux_resume_receiver/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_resume_receiver/#see-also","text":"flux resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/flux_suspend/","text":"flux suspend \u00b6 Suspend resources Synopsis \u00b6 The suspend sub-commands suspend the reconciliation of a resource. Options \u00b6 -h, --help help for suspend Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines flux suspend alert - Suspend reconciliation of Alert flux suspend helmrelease - Suspend reconciliation of HelmRelease flux suspend kustomization - Suspend reconciliation of Kustomization flux suspend receiver - Suspend reconciliation of Receiver","title":"Suspend"},{"location":"cmd/flux_suspend/#flux-suspend","text":"Suspend resources","title":"flux suspend"},{"location":"cmd/flux_suspend/#synopsis","text":"The suspend sub-commands suspend the reconciliation of a resource.","title":"Synopsis"},{"location":"cmd/flux_suspend/#options","text":"-h, --help help for suspend","title":"Options"},{"location":"cmd/flux_suspend/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_suspend/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines flux suspend alert - Suspend reconciliation of Alert flux suspend helmrelease - Suspend reconciliation of HelmRelease flux suspend kustomization - Suspend reconciliation of Kustomization flux suspend receiver - Suspend reconciliation of Receiver","title":"SEE ALSO"},{"location":"cmd/flux_suspend_alert/","text":"flux suspend alert \u00b6 Suspend reconciliation of Alert Synopsis \u00b6 The suspend command disables the reconciliation of a Alert resource. flux suspend alert [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Alert flux suspend alert main Options \u00b6 -h, --help help for alert Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux suspend - Suspend resources","title":"Suspend alert"},{"location":"cmd/flux_suspend_alert/#flux-suspend-alert","text":"Suspend reconciliation of Alert","title":"flux suspend alert"},{"location":"cmd/flux_suspend_alert/#synopsis","text":"The suspend command disables the reconciliation of a Alert resource. flux suspend alert [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_suspend_alert/#examples","text":"# Suspend reconciliation for an existing Alert flux suspend alert main","title":"Examples"},{"location":"cmd/flux_suspend_alert/#options","text":"-h, --help help for alert","title":"Options"},{"location":"cmd/flux_suspend_alert/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_suspend_alert/#see-also","text":"flux suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/flux_suspend_helmrelease/","text":"flux suspend helmrelease \u00b6 Suspend reconciliation of HelmRelease Synopsis \u00b6 The suspend command disables the reconciliation of a HelmRelease resource. flux suspend helmrelease [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Helm release flux suspend hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux suspend - Suspend resources","title":"Suspend helmrelease"},{"location":"cmd/flux_suspend_helmrelease/#flux-suspend-helmrelease","text":"Suspend reconciliation of HelmRelease","title":"flux suspend helmrelease"},{"location":"cmd/flux_suspend_helmrelease/#synopsis","text":"The suspend command disables the reconciliation of a HelmRelease resource. flux suspend helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_suspend_helmrelease/#examples","text":"# Suspend reconciliation for an existing Helm release flux suspend hr podinfo","title":"Examples"},{"location":"cmd/flux_suspend_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/flux_suspend_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_suspend_helmrelease/#see-also","text":"flux suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/flux_suspend_kustomization/","text":"flux suspend kustomization \u00b6 Suspend reconciliation of Kustomization Synopsis \u00b6 The suspend command disables the reconciliation of a Kustomization resource. flux suspend kustomization [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Kustomization flux suspend ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux suspend - Suspend resources","title":"Suspend kustomization"},{"location":"cmd/flux_suspend_kustomization/#flux-suspend-kustomization","text":"Suspend reconciliation of Kustomization","title":"flux suspend kustomization"},{"location":"cmd/flux_suspend_kustomization/#synopsis","text":"The suspend command disables the reconciliation of a Kustomization resource. flux suspend kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_suspend_kustomization/#examples","text":"# Suspend reconciliation for an existing Kustomization flux suspend ks podinfo","title":"Examples"},{"location":"cmd/flux_suspend_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/flux_suspend_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_suspend_kustomization/#see-also","text":"flux suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/flux_suspend_receiver/","text":"flux suspend receiver \u00b6 Suspend reconciliation of Receiver Synopsis \u00b6 The suspend command disables the reconciliation of a Receiver resource. flux suspend receiver [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Receiver flux suspend receiver main Options \u00b6 -h, --help help for receiver Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux suspend - Suspend resources","title":"Suspend receiver"},{"location":"cmd/flux_suspend_receiver/#flux-suspend-receiver","text":"Suspend reconciliation of Receiver","title":"flux suspend receiver"},{"location":"cmd/flux_suspend_receiver/#synopsis","text":"The suspend command disables the reconciliation of a Receiver resource. flux suspend receiver [name] [flags]","title":"Synopsis"},{"location":"cmd/flux_suspend_receiver/#examples","text":"# Suspend reconciliation for an existing Receiver flux suspend receiver main","title":"Examples"},{"location":"cmd/flux_suspend_receiver/#options","text":"-h, --help help for receiver","title":"Options"},{"location":"cmd/flux_suspend_receiver/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_suspend_receiver/#see-also","text":"flux suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/flux_uninstall/","text":"flux uninstall \u00b6 Uninstall the toolkit components Synopsis \u00b6 The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. flux uninstall [flags] Examples \u00b6 # Dry-run uninstall of all components flux uninstall --dry-run --namespace=flux-system # Uninstall all components and delete custom resource definitions flux uninstall --resources --crds --namespace=flux-system Options \u00b6 --crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories (default true) -s, --silent delete components without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 flux - Command line utility for assembling Kubernetes CD pipelines","title":"Uninstall"},{"location":"cmd/flux_uninstall/#flux-uninstall","text":"Uninstall the toolkit components","title":"flux uninstall"},{"location":"cmd/flux_uninstall/#synopsis","text":"The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. flux uninstall [flags]","title":"Synopsis"},{"location":"cmd/flux_uninstall/#examples","text":"# Dry-run uninstall of all components flux uninstall --dry-run --namespace=flux-system # Uninstall all components and delete custom resource definitions flux uninstall --resources --crds --namespace=flux-system","title":"Examples"},{"location":"cmd/flux_uninstall/#options","text":"--crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories (default true) -s, --silent delete components without asking for confirmation","title":"Options"},{"location":"cmd/flux_uninstall/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"flux-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/flux_uninstall/#see-also","text":"flux - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"components/helm/api/","text":"HelmRelease API reference Packages: helm.toolkit.fluxcd.io/v2beta1 helm.toolkit.fluxcd.io/v2beta1 Package v2beta1 contains API Schema definitions for the helm v2beta1 API group Resource Types: HelmRelease HelmRelease HelmRelease is the Schema for the helmreleases API Field Description apiVersion string helm.toolkit.fluxcd.io/v2beta1 kind string HelmRelease metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmReleaseSpec chart HelmChartTemplate Chart defines the template of the v1beta1.HelmChart that should be created for this HelmRelease. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. kubeConfig KubeConfig (Optional) KubeConfig for reconciling the HelmRelease on a remote cluster. suspend bool (Optional) Suspend tells the controller to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to HelmRelease resources that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this HelmRelease. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this HelmRelease. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. test Test (Optional) Test holds the configuration for Helm test actions for this HelmRelease. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this HelmRelease. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values for this HelmRelease, and information about how they should be merged. values Kubernetes pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. status HelmReleaseStatus CrossNamespaceObjectReference ( Appears on: HelmChartTemplateSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level. Field Description apiVersion string (Optional) APIVersion of the referent. kind string Kind of the referent. name string Name of the referent. namespace string (Optional) Namespace of the referent. DeploymentAction DeploymentAction defines a consistent interface for Install and Upgrade. HelmChartTemplate ( Appears on: HelmReleaseSpec ) HelmChartTemplate defines the template from which the controller will generate a v1beta1.HelmChart object in the same namespace as the referenced v1beta1.Source. Field Description spec HelmChartTemplateSpec Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) Version semver expression, ignored for charts from v1beta1.GitRepository and v1beta1.Bucket sources. Defaults to latest when omitted. sourceRef CrossNamespaceObjectReference The name and namespace of the v1beta1.Source the chart is available at. interval Kubernetes meta/v1.Duration (Optional) Interval at which to check the v1beta1.Source for updates. Defaults to \u2018HelmReleaseSpec.Interval\u2019. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmChartTemplateSpec ( Appears on: HelmChartTemplate ) HelmChartTemplateSpec defines the template from which the controller will generate a v1beta1.HelmChartSpec object. Field Description chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) Version semver expression, ignored for charts from v1beta1.GitRepository and v1beta1.Bucket sources. Defaults to latest when omitted. sourceRef CrossNamespaceObjectReference The name and namespace of the v1beta1.Source the chart is available at. interval Kubernetes meta/v1.Duration (Optional) Interval at which to check the v1beta1.Source for updates. Defaults to \u2018HelmReleaseSpec.Interval\u2019. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmReleaseSpec ( Appears on: HelmRelease ) HelmReleaseSpec defines the desired state of a Helm release. Field Description chart HelmChartTemplate Chart defines the template of the v1beta1.HelmChart that should be created for this HelmRelease. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. kubeConfig KubeConfig (Optional) KubeConfig for reconciling the HelmRelease on a remote cluster. suspend bool (Optional) Suspend tells the controller to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to HelmRelease resources that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this HelmRelease. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this HelmRelease. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. test Test (Optional) Test holds the configuration for Helm test actions for this HelmRelease. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this HelmRelease. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values for this HelmRelease, and information about how they should be merged. values Kubernetes pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. HelmReleaseStatus ( Appears on: HelmRelease ) HelmReleaseStatus defines the observed state of a HelmRelease. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. ReconcileRequestStatus github.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus (Members of ReconcileRequestStatus are embedded into this type.) conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmRelease. lastAppliedRevision string (Optional) LastAppliedRevision is the revision of the last successfully applied source. lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. lastAttemptedValuesChecksum string (Optional) LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last reconciliation attempt. lastReleaseRevision int (Optional) LastReleaseRevision is the revision of the last successful Helm release. helmChart string (Optional) HelmChart is the namespaced name of the HelmChart resource created by the controller for the HelmRelease. failures int64 (Optional) Failures is the reconciliation failure count against the latest desired state. It is reset after a successful reconciliation. installFailures int64 (Optional) InstallFailures is the install failure count against the latest desired state. It is reset after a successful reconciliation. upgradeFailures int64 (Optional) UpgradeFailures is the upgrade failure count against the latest desired state. It is reset after a successful reconciliation. Install ( Appears on: HelmReleaseSpec ) Install holds the configuration for Helm install actions performed for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm install action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. remediation InstallRemediation (Optional) Remediation holds the remediation configuration for when the Helm install action for the HelmRelease fails. The default is to not perform any action. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm install has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm install action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm install action from validating rendered templates against the Kubernetes OpenAPI Schema. replace bool (Optional) Replace tells the Helm install action to re-use the \u2018ReleaseName\u2019, but only if that name is a deleted release which remains in the history. skipCRDs bool (Optional) SkipCRDs tells the Helm install action to not install any CRDs. By default, CRDs are installed if not already present. InstallRemediation ( Appears on: Install ) InstallRemediation holds the configuration for Helm install remediation. Field Description retries int (Optional) Retries is the number of retries that should be attempted on failures before bailing. Remediation, using an uninstall, is performed between each attempt. Defaults to \u20180\u2019, a negative integer equals to unlimited retries. ignoreTestFailures bool (Optional) IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an install action but fail. Defaults to \u2018Test.IgnoreFailures\u2019. remediateLastFailure bool (Optional) RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to \u2018false\u2019. KubeConfig ( Appears on: HelmReleaseSpec ) KubeConfig references a Kubernetes secret that contains a kubeconfig file. Field Description secretRef Kubernetes core/v1.LocalObjectReference SecretRef holds the name to a secret that contains a \u2018value\u2019 key with the kubeconfig file as the value. It must be in the same namespace as the HelmRelease. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific cmd-path auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the HelmRelease. Remediation Remediation defines a consistent interface for InstallRemediation and UpgradeRemediation. RemediationStrategy ( string alias) ( Appears on: UpgradeRemediation ) RemediationStrategy returns the strategy to use to remediate a failed install or upgrade. Rollback ( Appears on: HelmReleaseSpec ) Rollback holds the configuration for Helm rollback actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm rollback action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm rollback has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. recreate bool (Optional) Recreate performs pod restarts for the resource if applicable. force bool (Optional) Force forces resource updates through a replacement strategy. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm rollback action when it fails. Test ( Appears on: HelmReleaseSpec ) Test holds the configuration for Helm test actions for this HelmRelease. Field Description enable bool (Optional) Enable enables Helm test actions for this HelmRelease after an Helm install or upgrade action has been performed. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation during the performance of a Helm test action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. ignoreFailures bool (Optional) IgnoreFailures tells the controller to skip remediation when the Helm tests are run but fail. Can be overwritten for tests run after install or upgrade actions in \u2018Install.IgnoreTestFailures\u2019 and \u2018Upgrade.IgnoreTestFailures\u2019. Uninstall ( Appears on: HelmReleaseSpec ) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm uninstall action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. keepHistory bool (Optional) KeepHistory tells Helm to remove all associated resources and mark the release as deleted, but retain the release history. Upgrade ( Appears on: HelmReleaseSpec ) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm upgrade action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. remediation UpgradeRemediation (Optional) Remediation holds the remediation configuration for when the Helm upgrade action for the HelmRelease fails. The default is to not perform any action. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm upgrade has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm upgrade action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm upgrade action from validating rendered templates against the Kubernetes OpenAPI Schema. force bool (Optional) Force forces resource updates through a replacement strategy. preserveValues bool (Optional) PreserveValues will make Helm reuse the last release\u2019s values and merge in overrides from \u2018Values\u2019. Setting this flag makes the HelmRelease non-declarative. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm upgrade action when it fails. UpgradeRemediation ( Appears on: Upgrade ) UpgradeRemediation holds the configuration for Helm upgrade remediation. Field Description retries int (Optional) Retries is the number of retries that should be attempted on failures before bailing. Remediation, using \u2018Strategy\u2019, is performed between each attempt. Defaults to \u20180\u2019, a negative integer equals to unlimited retries. ignoreTestFailures bool (Optional) IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an upgrade action but fail. Defaults to \u2018Test.IgnoreFailures\u2019. remediateLastFailure bool (Optional) RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to \u2018false\u2019 unless \u2018Retries\u2019 is greater than 0. strategy RemediationStrategy (Optional) Strategy to use for failure remediation. Defaults to \u2018rollback\u2019. ValuesReference ( Appears on: HelmReleaseSpec ) ValuesReference contains a reference to a resource containing Helm values, and optionally the key they can be found at. Field Description kind string Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019). name string Name of the values referent. Should reside in the same namespace as the referring resource. valuesKey string (Optional) ValuesKey is the data key where the values.yaml or a specific value can be found at. Defaults to \u2018values.yaml\u2019. targetPath string (Optional) TargetPath is the YAML dot notation path the value should be merged at. When set, the ValuesKey is expected to be a single flat value. Defaults to \u2018None\u2019, which results in the values getting merged at the root. optional bool (Optional) Optional marks this ValuesReference as optional. When set, a not found error for the values reference is ignored, but any ValuesKey, TargetPath or transient error will still result in a reconciliation failure. This page was automatically generated with gen-crd-api-reference-docs","title":"Helm API Reference"},{"location":"components/helm/controller/","text":"Helm Controller \u00b6 The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Supports HelmChart artifacts produced from HelmRepository and GitRepository sources Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (including semver ranges for charts from HelmRepository sources) Performs automated Helm actions, including Helm tests, rollbacks and uninstalls Offers extensive configuration options for automated remediation (rollback, uninstall, retry) on failed Helm install, upgrade or test actions Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship defined in a set of HelmRelease objects Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases statuses (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Overview"},{"location":"components/helm/controller/#helm-controller","text":"The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Supports HelmChart artifacts produced from HelmRepository and GitRepository sources Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (including semver ranges for charts from HelmRepository sources) Performs automated Helm actions, including Helm tests, rollbacks and uninstalls Offers extensive configuration options for automated remediation (rollback, uninstall, retry) on failed Helm install, upgrade or test actions Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship defined in a set of HelmRelease objects Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases statuses (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Helm Controller"},{"location":"components/helm/helmreleases/","text":"Helm Releases \u00b6 The HelmRelease API defines a resource for automated controller driven Helm releases. Specification \u00b6 A HelmRelease object defines a resource for controller driven reconciliation of Helm releases via Helm actions such as install, upgrade, test, uninstall, and rollback. This includes release placement (namespace/name), release content (chart/values overrides), action trigger configuration, individual action configuration, and statusing. // HelmReleaseSpec defines the desired state of a Helm Release. type HelmReleaseSpec struct { // Chart defines the template of the v1beta1.HelmChart that should be created // for this HelmRelease. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // KubeConfig for reconciling the HelmRelease on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Suspend tells the controller to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=53 // +kubebuilder:validation:Optional // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with // references to HelmRelease resources that must be ready before this HelmRelease // can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this HelmRelease. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this HelmRelease. // +optional Install * Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. // +optional Upgrade * Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this HelmRelease. // +optional Test * Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this HelmRelease. // +optional Rollback * Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. // +optional Uninstall * Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values for this HelmRelease, // and information about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\"` // Values holds the values for this Helm release. // +optional Values * apiextensionsv1 . JSON `json:\"values,omitempty\"` } // KubeConfig references a Kubernetes secret that contains a kubeconfig file. type KubeConfig struct { // SecretRef holds the name to a secret that contains a 'value' key with // the kubeconfig file as the value. It must be in the same namespace as // the HelmRelease. // It is recommended that the kubeconfig is self-contained, and the secret // is regularly updated if credentials such as a cloud-access-token expire. // Cloud specific `cmd-path` auth helpers will not function without adding // binaries and credentials to the Pod that is responsible for reconciling // the HelmRelease. // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } // HelmChartTemplate defines the template from which the controller will // generate a v1beta1.HelmChart object in the same namespace as the referenced // v1beta1.Source. type HelmChartTemplate struct { // Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. // +required Spec HelmChartTemplateSpec `json:\"spec\"` } // HelmChartTemplateSpec defines the template from which the controller will // generate a v1beta1.HelmChartSpec object. type HelmChartTemplateSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // Version semver expression, ignored for charts from v1beta1.GitRepository and // v1beta1.Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The name and namespace of the v1beta1.Source the chart is available at. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // Interval at which to check the v1beta1.Source for updates. Defaults to // 'HelmReleaseSpec.Interval'. // +optional Interval * metav1 . Duration `json:\"interval,omitempty\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } // Install holds the configuration for Helm install actions performed for this // HelmRelease. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm install // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * InstallRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // install has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but only // if that name is a deleted release which remains in the history. // +optional Replace bool `json:\"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool `json:\"skipCRDs,omitempty\"` } // InstallRemediation holds the configuration for Helm install remediation. type InstallRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using an uninstall, is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an install action but fail. Defaults to // 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false'. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions for this // HelmRelease. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm upgrade // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * UpgradeRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // upgrade has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge in // overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool `json:\"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // UpgradeRemediation holds the configuration for Helm upgrade remediation. type UpgradeRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using 'Strategy', is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an upgrade action but fail. // Defaults to 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false' unless 'Retries' is greater than 0. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` // Strategy to use for failure remediation. Defaults to 'rollback'. // +kubebuilder:validation:Enum=rollback;uninstall // +optional Strategy * RemediationStrategy `json:\"strategy,omitempty\"` } // Test holds the configuration for Helm test actions for this HelmRelease. type Test struct { // Enable enables Helm test actions for this HelmRelease after an Helm install // or upgrade action has been performed. // +optional Enable bool `json:\"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation during // the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // IgnoreFailures tells the controller to skip remediation when the Helm tests // are run but fail. Can be overwritten for tests run after install or upgrade // actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'. // +optional IgnoreFailures bool `json:\"ignoreFailures,omitempty\"` } // Rollback holds the configuration for Helm rollback actions for this // HelmRelease. type Rollback struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // rollback has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool `json:\"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions for this // HelmRelease. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm uninstall action. Defaults // to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the // release as deleted, but retain the release history. // +optional KeepHistory bool `json:\"keepHistory,omitempty\"` } Reference types \u00b6 // CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // Namespace of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // ValuesKey is the data key where the values.yaml or a specific value can be // found at. Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` // TargetPath is the YAML dot notation path the value should be merged at. When // set, the ValuesKey is expected to be a single flat value. Defaults to 'None', // which results in the values getting merged at the root. // +optional TargetPath string `json:\"targetPath,omitempty\"` // Optional marks this ValuesReference as optional. When set, a not found error // for the values reference is ignored, but any ValuesKey, TargetPath or // transient error will still result in a reconciliation failure. // +optional Optional bool `json:\"optional,omitempty\"` } Status specification \u00b6 // HelmReleaseStatus defines the observed state of a HelmRelease. type HelmReleaseStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the HelmRelease) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // Conditions holds the conditions for the HelmRelease. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // LastAppliedRevision is the revision of the last successfully applied source. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last // reconciliation attempt. // +optional LastAttemptedValuesChecksum string `json:\"lastAttemptedValuesChecksum,omitempty\"` // LastReleaseRevision is the revision of the last successful Helm release. // +optional LastReleaseRevision int `json:\"lastReleaseRevision,omitempty\"` // HelmChart is the namespaced name of the HelmChart resource created by // the controller for the HelmRelease. // +optional HelmChart string `json:\"helmChart,omitempty\"` // Failures is the reconciliation failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional Failures int64 `json:\"failures,omitempty\"` // InstallFailures is the install failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional InstallFailures int64 `json:\"installFailures,omitempty\"` // UpgradeFailures is the upgrade failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional UpgradeFailures int64 `json:\"upgradeFailures,omitempty\"` } Condition types \u00b6 const ( // ReleasedCondition represents the status of the last release attempt // (install/upgrade/test) against the latest desired state. ReleasedCondition string = \"Released\" // TestSuccessCondition represents the status of the last test attempt against // the latest desired state. TestSuccessCondition string = \"TestSuccess\" // RemediatedCondition represents the status of the last remediation attempt // (uninstall/rollback) due to a failure of the last release attempt against the // latest desired state. RemediatedCondition string = \"Remediated\" ) Condition reasons \u00b6 const ( // InstallSucceededReason represents the fact that the Helm install for the // HelmRelease succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the // HelmRelease failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the // HelmRelease succeeded. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the // HelmRelease failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestSucceededReason represents the fact that the Helm tests for the // HelmRelease succeeded. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm tests for the HelmRelease // failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the // HelmRelease succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the // HelmRelease failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the // HelmRelease succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the // HelmRelease failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the // HelmRelease failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm // configuration failed. InitFailedReason string = \"InitFailed\" // GetLastReleaseFailedReason represents the fact that observing the last // release failed. GetLastReleaseFailedReason string = \"GetLastReleaseFailed\" ) Helm release placement \u00b6 The namespace/name in which to deploy the Helm release defaults to the namespace/name of the HelmRelease . These can be overridden respectively via spec.targetNamespace and spec.releaseName . If spec.targetNamespace is set, spec.releaseName defaults to <spec.targetNamespace>-<metadata.name> . Note: that configuring the spec.targetNamespace only defines the namespace the release is made in, the metadata for the release (also known as the \"Helm storage\") will always be stored in the metadata.namespace of the HelmRelease . Helm chart template \u00b6 The spec.chart.spec values are used by the helm-controller as a template to create a new HelmChart resource with the given spec. The spec.chart.spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository GitRepository Bucket The HelmChart is created in the same namespace as the sourceRef , with a name matching the HelmRelease <metadata.namespace>-<metadata.name> . The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository or Bucket source. Values overrides \u00b6 The simplest way to define values overrides is inline via spec.values . It is also possible to define a list of ConfigMap and Secret resources from which to take values via spec.valuesFrom . The values are merged in the order given, with the later values overwriting earlier, and then spec.values overwriting those: spec : values : replicaCount : 2 valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt optional : true The definition of the listed keys for items in spec.valuesFrom is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. optional (Optional) : Whether this values reference is optional. When true , a not found error for the values reference is ignored, but any valuesKey, targetPath or transient error will still result in a reconciliation failure. Defaults to false when omitted. Note: that the targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation . Reconciliation \u00b6 If no Helm release with the matching namespace/name is found it will be installed. It will be upgraded any time the desired state is updated, which consists of: spec (and thus metadata.generation ) Latest HelmChart revision available ConfigMap and Secret values overrides . Changes to these do not trigger an immediate reconciliation, but will be handled upon the next reconciliation. This is to avoid a large number of upgrades occurring when multiple resources are updated. If the latest Helm release revision was not made by the helm-controller, it may not match the desired state, so an upgrade is made in this case as well. The spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be 60 seconds. The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with a reconcile.fluxcd.io/requestedAt annotation. For example: kubectl annotate --overwrite helmrelease/podinfo reconcile.fluxcd.io/requesteddAt = \" $( date +%s ) \" Reconciliation can be suspended by setting spec.suspend to true . The timeout for any individual Kubernetes operation (like Jobs for hooks) during the performance of Helm actions can be configured via spec.timeout and can be overridden per action via spec.<action>.timeout . Disabling resource waiting \u00b6 For install, upgrade, and rollback actions resource waiting is enabled by default, but can be disabled by setting spec.<action>.disableWait . HelmRelease dependencies \u00b6 When applying a HelmRelease , you may need to make sure other releases are Ready before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . The spec.dependsOn field allows you to specify each of these dependencies. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : backend namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m upgrade : remediation : remediateLastFailure : true test : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : frontend namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m dependsOn : - backend upgrade : remediation : remediateLastFailure : true test : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that this does not account for upgrade ordering. Kubernetes only allows applying one resource ( HelmRelease in this case) at a time, so there is no way for the controller to know when a dependency HelmRelease may be updated. Also, circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled. Configuring Helm test actions \u00b6 To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . By default, when tests are enabled, failures in tests are considered release failures, and thus are subject to the triggering Helm action's remediation configuration. However, test failures can be ignored by setting spec.test.ignoreFailures to true . In this case, no remediation will be taken, and the test failure will not affect the Released and Ready status conditions. This can be overridden per Helm action by setting spec.install.remediation.ignoreTestFailures or spec.upgrade.remediation.ignoreTestFailures . apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m test : enable : true ignoreFailures : true values : resources : requests : cpu : 100m memory : 64Mi Configuring failure remediation \u00b6 From time to time a Helm install/upgrade and accompanying Helm test may fail. When this occurs, by default no action is taken, and the release is left in a failed state. However, several automatic failure remediation options can be set via spec.install.remediation and spec.upgrade.remediation . The retries can be set to configure the number of retries after an initial failure. A negative integer results in infinite retries. This implicitly opts-in to a remediation action between each attempt. The remediation action for install failures is an uninstall. The remediation action for upgrade failures is by default a rollback, however spec.upgrade.remediation.strategy can be set to uninstall , in which case after the uninstall, the spec.install configuration takes over. One can also opt-in to remediation of the last failure (when no retries remain) by setting spec.<action>.remediation.remediateLastFailure to true . For upgrades, this defaults to true if at least one retry is configured. apiVersion : helm.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m install : remediation : retries : 3 upgrade : remediation : remediateLastFailure : false values : resources : requests : cpu : 100m memory : 64Mi Remote Clusters / Cluster-API \u00b6 If the spec.kubeConfig field is set, Helm actions will run against the default cluster specified in that KubeConfig instead of the local cluster that is responsible for the reconciliation of the HelmRelease. The secret defined in the spec.kubeConfig.secretRef must exist in the same namespace as the HelmRelease. On every reconciliation, the KubeConfig bytes will be loaded from the values key of the secret's data, and the secret can thus be regularly updated if cluster-access-tokens have to rotate due to expiration. The Helm storage is stored on the remote cluster in a namespace that equals to the namespace of the HelmRelease, the release itself is made in either this namespace, or the configured spec.targetNamespace . In any case, both are expected to exist. Other references to Kubernetes resources in the HelmRelease, like ValuesReference resources, are expected to exist on the reconciling cluster. This composes well with Cluster API bootstrap providers such as CAPBK (kubeadm), as well as the CAPA (AWS) EKS integration. To reconcile a HelmRelease to a CAPI controlled cluster, put the HelmRelease in the same namespace as your Cluster object, and set the spec.kubeConfig.secretRef.name to <cluster-name>-kubeconfig : apiVersion : cluster.x-k8s.io/v1alpha3 kind : Cluster metadata : name : stage # the kubeconfig Secret will contain the Cluster name namespace : capi-stage spec : clusterNetwork : pods : cidrBlocks : - 10.100.0.0/16 serviceDomain : stage-cluster.local services : cidrBlocks : - 10.200.0.0/12 controlPlaneRef : apiVersion : controlplane.cluster.x-k8s.io/v1alpha3 kind : KubeadmControlPlane name : stage-control-plane namespace : capi-stage infrastructureRef : apiVersion : infrastructure.cluster.x-k8s.io/v1alpha3 kind : DockerCluster name : stage namespace : capi-stage --- # ... unrelated Cluster API objects omitted for brevity ... --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : kube-prometheus-stack namespace : capi-stage spec : kubeConfig : secretRef : name : stage-kubeconfig # Cluster API creates this for the matching Cluster chart : spec : chart : prometheus version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : prometheus-community install : remediation : retries : -1 The Cluster and HelmRelease can be created at the same time if the install remediation configuration is set to a forgiving amount of retries. The HelmRelease will then eventually reconcile once the cluster is available. If you wish to target clusters created by other means than CAPI, you can create a ServiceAccount on the remote cluster, generate a KubeConfig for that account, and then create a secret on the cluster where helm-controller is running e.g.: kubectl -n default create secret generic prod-kubeconfig \\ --from-file = value = ./kubeconfig Note that the KubeConfig should be self-contained and not rely on binaries, environment, or credential files from the helm-controller Pod. This matches the constraints of KubeConfigs from current Cluster API providers. KubeConfigs with cmd-path in them likely won't work without a custom, per-provider installation of helm-controller. Status \u00b6 When the controller completes a reconciliation, it reports the result in the status sub-resource. The following status.condtions types are advertised. Here, \"desired state\" is as detailed in reconciliation : Ready - status of the last reconciliation attempt Released - status of the last release attempt (install/upgrade/test) against the latest desired state TestSuccess - status of the last test attempt against the latest desired state Remediated - status of the last remediation attempt (uninstall/rollback) due to a failure of the last release attempt against the latest desired state For example, you can wait for a successful helm-controller reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready Each of these conditions also include descriptive reason / message fields as to why the status is as such. Examples \u00b6 Install success \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test succeeded reason : TestSucceeded status : \"True\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2 Upgrade failure \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Released - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3 Ignored test failure \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test failed reason : TestFailed status : \"False\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"HelmRelease CRD"},{"location":"components/helm/helmreleases/#helm-releases","text":"The HelmRelease API defines a resource for automated controller driven Helm releases.","title":"Helm Releases"},{"location":"components/helm/helmreleases/#specification","text":"A HelmRelease object defines a resource for controller driven reconciliation of Helm releases via Helm actions such as install, upgrade, test, uninstall, and rollback. This includes release placement (namespace/name), release content (chart/values overrides), action trigger configuration, individual action configuration, and statusing. // HelmReleaseSpec defines the desired state of a Helm Release. type HelmReleaseSpec struct { // Chart defines the template of the v1beta1.HelmChart that should be created // for this HelmRelease. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // KubeConfig for reconciling the HelmRelease on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Suspend tells the controller to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=53 // +kubebuilder:validation:Optional // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with // references to HelmRelease resources that must be ready before this HelmRelease // can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this HelmRelease. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this HelmRelease. // +optional Install * Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. // +optional Upgrade * Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this HelmRelease. // +optional Test * Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this HelmRelease. // +optional Rollback * Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. // +optional Uninstall * Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values for this HelmRelease, // and information about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\"` // Values holds the values for this Helm release. // +optional Values * apiextensionsv1 . JSON `json:\"values,omitempty\"` } // KubeConfig references a Kubernetes secret that contains a kubeconfig file. type KubeConfig struct { // SecretRef holds the name to a secret that contains a 'value' key with // the kubeconfig file as the value. It must be in the same namespace as // the HelmRelease. // It is recommended that the kubeconfig is self-contained, and the secret // is regularly updated if credentials such as a cloud-access-token expire. // Cloud specific `cmd-path` auth helpers will not function without adding // binaries and credentials to the Pod that is responsible for reconciling // the HelmRelease. // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } // HelmChartTemplate defines the template from which the controller will // generate a v1beta1.HelmChart object in the same namespace as the referenced // v1beta1.Source. type HelmChartTemplate struct { // Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. // +required Spec HelmChartTemplateSpec `json:\"spec\"` } // HelmChartTemplateSpec defines the template from which the controller will // generate a v1beta1.HelmChartSpec object. type HelmChartTemplateSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // Version semver expression, ignored for charts from v1beta1.GitRepository and // v1beta1.Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The name and namespace of the v1beta1.Source the chart is available at. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // Interval at which to check the v1beta1.Source for updates. Defaults to // 'HelmReleaseSpec.Interval'. // +optional Interval * metav1 . Duration `json:\"interval,omitempty\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } // Install holds the configuration for Helm install actions performed for this // HelmRelease. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm install // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * InstallRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // install has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but only // if that name is a deleted release which remains in the history. // +optional Replace bool `json:\"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool `json:\"skipCRDs,omitempty\"` } // InstallRemediation holds the configuration for Helm install remediation. type InstallRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using an uninstall, is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an install action but fail. Defaults to // 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false'. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions for this // HelmRelease. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm upgrade // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * UpgradeRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // upgrade has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge in // overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool `json:\"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // UpgradeRemediation holds the configuration for Helm upgrade remediation. type UpgradeRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using 'Strategy', is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an upgrade action but fail. // Defaults to 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false' unless 'Retries' is greater than 0. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` // Strategy to use for failure remediation. Defaults to 'rollback'. // +kubebuilder:validation:Enum=rollback;uninstall // +optional Strategy * RemediationStrategy `json:\"strategy,omitempty\"` } // Test holds the configuration for Helm test actions for this HelmRelease. type Test struct { // Enable enables Helm test actions for this HelmRelease after an Helm install // or upgrade action has been performed. // +optional Enable bool `json:\"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation during // the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // IgnoreFailures tells the controller to skip remediation when the Helm tests // are run but fail. Can be overwritten for tests run after install or upgrade // actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'. // +optional IgnoreFailures bool `json:\"ignoreFailures,omitempty\"` } // Rollback holds the configuration for Helm rollback actions for this // HelmRelease. type Rollback struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // rollback has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool `json:\"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions for this // HelmRelease. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm uninstall action. Defaults // to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the // release as deleted, but retain the release history. // +optional KeepHistory bool `json:\"keepHistory,omitempty\"` }","title":"Specification"},{"location":"components/helm/helmreleases/#reference-types","text":"// CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // Namespace of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // ValuesKey is the data key where the values.yaml or a specific value can be // found at. Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` // TargetPath is the YAML dot notation path the value should be merged at. When // set, the ValuesKey is expected to be a single flat value. Defaults to 'None', // which results in the values getting merged at the root. // +optional TargetPath string `json:\"targetPath,omitempty\"` // Optional marks this ValuesReference as optional. When set, a not found error // for the values reference is ignored, but any ValuesKey, TargetPath or // transient error will still result in a reconciliation failure. // +optional Optional bool `json:\"optional,omitempty\"` }","title":"Reference types"},{"location":"components/helm/helmreleases/#status-specification","text":"// HelmReleaseStatus defines the observed state of a HelmRelease. type HelmReleaseStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the HelmRelease) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // Conditions holds the conditions for the HelmRelease. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // LastAppliedRevision is the revision of the last successfully applied source. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last // reconciliation attempt. // +optional LastAttemptedValuesChecksum string `json:\"lastAttemptedValuesChecksum,omitempty\"` // LastReleaseRevision is the revision of the last successful Helm release. // +optional LastReleaseRevision int `json:\"lastReleaseRevision,omitempty\"` // HelmChart is the namespaced name of the HelmChart resource created by // the controller for the HelmRelease. // +optional HelmChart string `json:\"helmChart,omitempty\"` // Failures is the reconciliation failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional Failures int64 `json:\"failures,omitempty\"` // InstallFailures is the install failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional InstallFailures int64 `json:\"installFailures,omitempty\"` // UpgradeFailures is the upgrade failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional UpgradeFailures int64 `json:\"upgradeFailures,omitempty\"` }","title":"Status specification"},{"location":"components/helm/helmreleases/#condition-types","text":"const ( // ReleasedCondition represents the status of the last release attempt // (install/upgrade/test) against the latest desired state. ReleasedCondition string = \"Released\" // TestSuccessCondition represents the status of the last test attempt against // the latest desired state. TestSuccessCondition string = \"TestSuccess\" // RemediatedCondition represents the status of the last remediation attempt // (uninstall/rollback) due to a failure of the last release attempt against the // latest desired state. RemediatedCondition string = \"Remediated\" )","title":"Condition types"},{"location":"components/helm/helmreleases/#condition-reasons","text":"const ( // InstallSucceededReason represents the fact that the Helm install for the // HelmRelease succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the // HelmRelease failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the // HelmRelease succeeded. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the // HelmRelease failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestSucceededReason represents the fact that the Helm tests for the // HelmRelease succeeded. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm tests for the HelmRelease // failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the // HelmRelease succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the // HelmRelease failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the // HelmRelease succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the // HelmRelease failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the // HelmRelease failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm // configuration failed. InitFailedReason string = \"InitFailed\" // GetLastReleaseFailedReason represents the fact that observing the last // release failed. GetLastReleaseFailedReason string = \"GetLastReleaseFailed\" )","title":"Condition reasons"},{"location":"components/helm/helmreleases/#helm-release-placement","text":"The namespace/name in which to deploy the Helm release defaults to the namespace/name of the HelmRelease . These can be overridden respectively via spec.targetNamespace and spec.releaseName . If spec.targetNamespace is set, spec.releaseName defaults to <spec.targetNamespace>-<metadata.name> . Note: that configuring the spec.targetNamespace only defines the namespace the release is made in, the metadata for the release (also known as the \"Helm storage\") will always be stored in the metadata.namespace of the HelmRelease .","title":"Helm release placement"},{"location":"components/helm/helmreleases/#helm-chart-template","text":"The spec.chart.spec values are used by the helm-controller as a template to create a new HelmChart resource with the given spec. The spec.chart.spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository GitRepository Bucket The HelmChart is created in the same namespace as the sourceRef , with a name matching the HelmRelease <metadata.namespace>-<metadata.name> . The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository or Bucket source.","title":"Helm chart template"},{"location":"components/helm/helmreleases/#values-overrides","text":"The simplest way to define values overrides is inline via spec.values . It is also possible to define a list of ConfigMap and Secret resources from which to take values via spec.valuesFrom . The values are merged in the order given, with the later values overwriting earlier, and then spec.values overwriting those: spec : values : replicaCount : 2 valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt optional : true The definition of the listed keys for items in spec.valuesFrom is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. optional (Optional) : Whether this values reference is optional. When true , a not found error for the values reference is ignored, but any valuesKey, targetPath or transient error will still result in a reconciliation failure. Defaults to false when omitted. Note: that the targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation .","title":"Values overrides"},{"location":"components/helm/helmreleases/#reconciliation","text":"If no Helm release with the matching namespace/name is found it will be installed. It will be upgraded any time the desired state is updated, which consists of: spec (and thus metadata.generation ) Latest HelmChart revision available ConfigMap and Secret values overrides . Changes to these do not trigger an immediate reconciliation, but will be handled upon the next reconciliation. This is to avoid a large number of upgrades occurring when multiple resources are updated. If the latest Helm release revision was not made by the helm-controller, it may not match the desired state, so an upgrade is made in this case as well. The spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be 60 seconds. The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with a reconcile.fluxcd.io/requestedAt annotation. For example: kubectl annotate --overwrite helmrelease/podinfo reconcile.fluxcd.io/requesteddAt = \" $( date +%s ) \" Reconciliation can be suspended by setting spec.suspend to true . The timeout for any individual Kubernetes operation (like Jobs for hooks) during the performance of Helm actions can be configured via spec.timeout and can be overridden per action via spec.<action>.timeout .","title":"Reconciliation"},{"location":"components/helm/helmreleases/#disabling-resource-waiting","text":"For install, upgrade, and rollback actions resource waiting is enabled by default, but can be disabled by setting spec.<action>.disableWait .","title":"Disabling resource waiting"},{"location":"components/helm/helmreleases/#helmrelease-dependencies","text":"When applying a HelmRelease , you may need to make sure other releases are Ready before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . The spec.dependsOn field allows you to specify each of these dependencies. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : backend namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m upgrade : remediation : remediateLastFailure : true test : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : frontend namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m dependsOn : - backend upgrade : remediation : remediateLastFailure : true test : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that this does not account for upgrade ordering. Kubernetes only allows applying one resource ( HelmRelease in this case) at a time, so there is no way for the controller to know when a dependency HelmRelease may be updated. Also, circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled.","title":"HelmRelease dependencies"},{"location":"components/helm/helmreleases/#configuring-helm-test-actions","text":"To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . By default, when tests are enabled, failures in tests are considered release failures, and thus are subject to the triggering Helm action's remediation configuration. However, test failures can be ignored by setting spec.test.ignoreFailures to true . In this case, no remediation will be taken, and the test failure will not affect the Released and Ready status conditions. This can be overridden per Helm action by setting spec.install.remediation.ignoreTestFailures or spec.upgrade.remediation.ignoreTestFailures . apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m test : enable : true ignoreFailures : true values : resources : requests : cpu : 100m memory : 64Mi","title":"Configuring Helm test actions"},{"location":"components/helm/helmreleases/#configuring-failure-remediation","text":"From time to time a Helm install/upgrade and accompanying Helm test may fail. When this occurs, by default no action is taken, and the release is left in a failed state. However, several automatic failure remediation options can be set via spec.install.remediation and spec.upgrade.remediation . The retries can be set to configure the number of retries after an initial failure. A negative integer results in infinite retries. This implicitly opts-in to a remediation action between each attempt. The remediation action for install failures is an uninstall. The remediation action for upgrade failures is by default a rollback, however spec.upgrade.remediation.strategy can be set to uninstall , in which case after the uninstall, the spec.install configuration takes over. One can also opt-in to remediation of the last failure (when no retries remain) by setting spec.<action>.remediation.remediateLastFailure to true . For upgrades, this defaults to true if at least one retry is configured. apiVersion : helm.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : default interval : 1m install : remediation : retries : 3 upgrade : remediation : remediateLastFailure : false values : resources : requests : cpu : 100m memory : 64Mi","title":"Configuring failure remediation"},{"location":"components/helm/helmreleases/#remote-clusters-cluster-api","text":"If the spec.kubeConfig field is set, Helm actions will run against the default cluster specified in that KubeConfig instead of the local cluster that is responsible for the reconciliation of the HelmRelease. The secret defined in the spec.kubeConfig.secretRef must exist in the same namespace as the HelmRelease. On every reconciliation, the KubeConfig bytes will be loaded from the values key of the secret's data, and the secret can thus be regularly updated if cluster-access-tokens have to rotate due to expiration. The Helm storage is stored on the remote cluster in a namespace that equals to the namespace of the HelmRelease, the release itself is made in either this namespace, or the configured spec.targetNamespace . In any case, both are expected to exist. Other references to Kubernetes resources in the HelmRelease, like ValuesReference resources, are expected to exist on the reconciling cluster. This composes well with Cluster API bootstrap providers such as CAPBK (kubeadm), as well as the CAPA (AWS) EKS integration. To reconcile a HelmRelease to a CAPI controlled cluster, put the HelmRelease in the same namespace as your Cluster object, and set the spec.kubeConfig.secretRef.name to <cluster-name>-kubeconfig : apiVersion : cluster.x-k8s.io/v1alpha3 kind : Cluster metadata : name : stage # the kubeconfig Secret will contain the Cluster name namespace : capi-stage spec : clusterNetwork : pods : cidrBlocks : - 10.100.0.0/16 serviceDomain : stage-cluster.local services : cidrBlocks : - 10.200.0.0/12 controlPlaneRef : apiVersion : controlplane.cluster.x-k8s.io/v1alpha3 kind : KubeadmControlPlane name : stage-control-plane namespace : capi-stage infrastructureRef : apiVersion : infrastructure.cluster.x-k8s.io/v1alpha3 kind : DockerCluster name : stage namespace : capi-stage --- # ... unrelated Cluster API objects omitted for brevity ... --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : kube-prometheus-stack namespace : capi-stage spec : kubeConfig : secretRef : name : stage-kubeconfig # Cluster API creates this for the matching Cluster chart : spec : chart : prometheus version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : prometheus-community install : remediation : retries : -1 The Cluster and HelmRelease can be created at the same time if the install remediation configuration is set to a forgiving amount of retries. The HelmRelease will then eventually reconcile once the cluster is available. If you wish to target clusters created by other means than CAPI, you can create a ServiceAccount on the remote cluster, generate a KubeConfig for that account, and then create a secret on the cluster where helm-controller is running e.g.: kubectl -n default create secret generic prod-kubeconfig \\ --from-file = value = ./kubeconfig Note that the KubeConfig should be self-contained and not rely on binaries, environment, or credential files from the helm-controller Pod. This matches the constraints of KubeConfigs from current Cluster API providers. KubeConfigs with cmd-path in them likely won't work without a custom, per-provider installation of helm-controller.","title":"Remote Clusters / Cluster-API"},{"location":"components/helm/helmreleases/#status","text":"When the controller completes a reconciliation, it reports the result in the status sub-resource. The following status.condtions types are advertised. Here, \"desired state\" is as detailed in reconciliation : Ready - status of the last reconciliation attempt Released - status of the last release attempt (install/upgrade/test) against the latest desired state TestSuccess - status of the last test attempt against the latest desired state Remediated - status of the last remediation attempt (uninstall/rollback) due to a failure of the last release attempt against the latest desired state For example, you can wait for a successful helm-controller reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready Each of these conditions also include descriptive reason / message fields as to why the status is as such.","title":"Status"},{"location":"components/helm/helmreleases/#examples","text":"","title":"Examples"},{"location":"components/helm/helmreleases/#install-success","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test succeeded reason : TestSucceeded status : \"True\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"Install success"},{"location":"components/helm/helmreleases/#upgrade-failure","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Released - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3","title":"Upgrade failure"},{"location":"components/helm/helmreleases/#ignored-test-failure","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test failed reason : TestFailed status : \"False\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"Ignored test failure"},{"location":"components/kustomize/api/","text":"Kustomize API reference Packages: kustomize.toolkit.fluxcd.io/v1beta1 kustomize.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the kustomize v1beta1 API group Resource Types: Kustomization Kustomization Kustomization is the Schema for the kustomizations API. Field Description apiVersion string kustomize.toolkit.fluxcd.io/v1beta1 kind string Kustomization metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec KustomizationSpec dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled. decryption Decryption (Optional) Decrypt Kubernetes secrets before applying them on the cluster. interval Kubernetes meta/v1.Duration The interval at which to reconcile the kustomization. kubeConfig KubeConfig (Optional) The KubeConfig for reconciling the Kustomization on a remote cluster. path string Path to the directory containing the kustomization file. prune bool Prune enables garbage collection. healthChecks []CrossNamespaceObjectReference (Optional) A list of resources to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceSourceReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. targetNamespace string (Optional) TargetNamespace sets or overrides the namespace in the kustomization.yaml file. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). status KustomizationStatus CrossNamespaceObjectReference ( Appears on: KustomizationSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent, defaults to \u2018apps/v1\u2019 kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent CrossNamespaceSourceReference ( Appears on: KustomizationSpec ) CrossNamespaceSourceReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent, defaults to the Kustomization namespace Decryption ( Appears on: KustomizationSpec ) Decryption defines how decryption is handled for Kubernetes manifests. Field Description provider string Provider is the name of the decryption engine. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the private OpenPGP keys used for decryption. KubeConfig ( Appears on: KustomizationSpec ) KubeConfig references a Kubernetes secret that contains a kubeconfig file. Field Description secretRef Kubernetes core/v1.LocalObjectReference SecretRef holds the name to a secret that contains a \u2018value\u2019 key with the kubeconfig file as the value. It must be in the same namespace as the Kustomization. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific cmd-path auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the Kustomization. KustomizationSpec ( Appears on: Kustomization ) KustomizationSpec defines the desired state of a kustomization. Field Description dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled. decryption Decryption (Optional) Decrypt Kubernetes secrets before applying them on the cluster. interval Kubernetes meta/v1.Duration The interval at which to reconcile the kustomization. kubeConfig KubeConfig (Optional) The KubeConfig for reconciling the Kustomization on a remote cluster. path string Path to the directory containing the kustomization file. prune bool Prune enables garbage collection. healthChecks []CrossNamespaceObjectReference (Optional) A list of resources to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceSourceReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. targetNamespace string (Optional) TargetNamespace sets or overrides the namespace in the kustomization.yaml file. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). KustomizationStatus ( Appears on: Kustomization ) KustomizationStatus defines the observed state of a kustomization. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last reconciled generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) lastAppliedRevision string (Optional) The last successfully applied revision. The revision format for Git sources is / . lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. ReconcileRequestStatus github.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus (Members of ReconcileRequestStatus are embedded into this type.) snapshot Snapshot (Optional) The last successfully applied revision metadata. ServiceAccount ( Appears on: KustomizationSpec ) ServiceAccount defines a reference to a Kubernetes service account. Field Description name string Name is the name of the service account being referenced. namespace string Namespace is the namespace of the service account being referenced. Snapshot ( Appears on: KustomizationStatus ) Snapshot holds the metadata of the Kubernetes objects generated for a source revision Field Description checksum string The manifests sha1 checksum. entries []SnapshotEntry A list of Kubernetes kinds grouped by namespace. SnapshotEntry ( Appears on: Snapshot ) Snapshot holds the metadata of namespaced Kubernetes objects Field Description namespace string (Optional) The namespace of this entry. kinds map[string]string The list of Kubernetes kinds. This page was automatically generated with gen-crd-api-reference-docs","title":"Kustomize API Reference"},{"location":"components/kustomize/controller/","text":"Kustomize Controller \u00b6 The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Overview"},{"location":"components/kustomize/controller/#kustomize-controller","text":"The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Kustomize Controller"},{"location":"components/kustomize/kustomization/","text":"Kustomization \u00b6 The Kustomization API defines a pipeline for fetching, decrypting, building, validating and applying Kubernetes manifests. Specification \u00b6 A Kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice // with references to Kustomization resources that must be ready before this // Kustomization can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Decrypt Kubernetes secrets before applying them on the cluster. // +optional Decryption * Decryption `json:\"decryption,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // The KubeConfig for reconciling the Kustomization on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of resources to be included in the health assessment. // +optional HealthChecks [] CrossNamespaceObjectReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceSourceReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // TargetNamespace sets or overrides the namespace in the // kustomization.yaml file. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The decryption section defines how decryption is handled for Kubernetes manifests: type Decryption struct { // Provider is the name of the decryption engine. // +kubebuilder:validation:Enum=sops // +required Provider string `json:\"provider\"` // The secret name containing the private OpenPGP keys used for decryption. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } KubeConfig references a Kubernetes Secret for applying to another cluster. This can be used with Cluster API: type KubeConfig struct { // SecretRef holds the name to a secret that contains a 'value' key with // the kubeconfig file as the value. It must be in the same namespace as // the Kustomization. // It is recommended that the kubeconfig is self-contained, and the secret // is regularly updated if credentials such as a cloud-access-token expire. // Cloud specific `cmd-path` auth helpers will not function without adding // binaries and credentials to the Pod that is responsible for reconciling // the Kustomization. // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } The status sub-resource records the result of the last reconciliation: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the Kustomization) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition is the name of the condition that // records the readiness status of a Kustomization. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the // reconciliation of the Kustomization has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the // reconciliation of the Kustomization has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // ProgressingReason represents the fact that the // reconciliation of the Kustomization is underway. ProgressingReason string = \"Progressing\" // SuspendedReason represents the fact that the // reconciliation of the Kustomization has been suspended. SuspendedReason string = \"Suspended\" // DependencyNotReady represents the fact that // one of the dependencies of the Kustomization is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // PruneFailedReason represents the fact that the // pruning of the Kustomization failed. PruneFailedReason string = \"PruneFailed\" // ArtifactFailedReason represents the fact that the // artifact download of the kustomization failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the // kustomize build of the Kustomization failed. BuildFailedReason string = \"BuildFailed\" // HealthCheckFailedReason represents the fact that // one of the health checks of the Kustomization failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // ValidationFailedReason represents the fact that the // validation of the Kustomization manifests has failed. ValidationFailedReason string = \"ValidationFailed\" ) Source reference \u00b6 The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Bucket Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your Git repository or S3 bucket contains only plain manifests, then a kustomization.yaml will be automatically generated. Generate kustomization.yaml \u00b6 If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection . Reconciliation \u00b6 The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"reconcile.fluxcd.io/requestedAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo reconcile.fluxcd.io/requestedAt = \" $( date +%s ) \" Garbage collection \u00b6 To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster. Health assessment \u00b6 A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads and the ready status of custom resources. A health check entry can reference one of the following types: Kubernetes builtin kinds: Deployment, DaemonSet, StatefulSet, PersistentVolumeClaim, Pod, PodDisruptionBudget, Job, CronJob, Service, Secret, ConfigMap, CustomResourceDefinition Toolkit kinds: HelmRelease, HelmRepository, GitRepository, etc Custom resources that are compatible with kstatus Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : apps/v1 kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready. When a Kustomization contains HelmRelease objects, instead of checking the underling Deployments, you can define a health check that waits for the HelmReleases to be reconciled with: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : webapp namespace : default spec : interval : 15m path : \"./releases/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : frontend namespace : dev - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : backend namespace : dev timeout : 5m If all the HelmRelease objects are successfully installed or upgraded, then the Kustomization will be marked as ready. Kustomization dependencies \u00b6 When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : common namespace : default spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : dependsOn : - name : common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : istio namespace : istio-system spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : dependsOn : - name : common - name : istio namespace : istio-system interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster. Role-based access control \u00b6 By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : webapp spec : dependsOn : - name : common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace. Remote Clusters / Cluster-API \u00b6 If the kubeConfig field is set, objects will be applied, health-checked, pruned, and deleted for the default cluster specified in that KubeConfig instead of using the in-cluster ServiceAccount. The secret defined in the kubeConfig.SecretRef must exist in the same namespace as the Kustomization. On every reconciliation, the KubeConfig bytes will be loaded from the values key of the secret's data, and the secret can thus be regularly updated if cluster-access-tokens have to rotate due to expiration. This composes well with Cluster API bootstrap providers such as CAPBK (kubeadm) as well as the CAPA (AWS) EKS integration. To reconcile a Kustomization to a CAPI controlled cluster, put the Kustomization in the same namespace as your Cluster object, and set the kubeConfig.secretRef.name to <cluster-name>-kubeconfig : apiVersion : cluster.x-k8s.io/v1alpha3 kind : Cluster metadata : name : stage # the kubeconfig Secret will contain the Cluster name namespace : capi-stage spec : clusterNetwork : pods : cidrBlocks : - 10.100.0.0/16 serviceDomain : stage-cluster.local services : cidrBlocks : - 10.200.0.0/12 controlPlaneRef : apiVersion : controlplane.cluster.x-k8s.io/v1alpha3 kind : KubeadmControlPlane name : stage-control-plane namespace : capi-stage infrastructureRef : apiVersion : infrastructure.cluster.x-k8s.io/v1alpha3 kind : DockerCluster name : stage namespace : capi-stage --- # ... unrelated Cluster API objects omitted for brevity ... --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : cluster-addons namespace : capi-stage spec : interval : 5m path : \"./config/addons/\" prune : true sourceRef : kind : GitRepository name : cluster-addons kubeConfig : secretRef : name : stage-kubeconfig # Cluster API creates this for the matching Cluster The Cluster and Kustomization can be created at the same time. The Kustomization will eventually reconcile once the cluster is available. If you wish to target clusters created by other means than CAPI, you can create a ServiceAccount on the remote cluster, generate a KubeConfig for that account, and then create a secret on the cluster where kustomize-controller is running e.g.: kubectl create secret generic prod-kubeconfig \\ --from-file = value = ./kubeconfig Note that the KubeConfig should be self-contained and not rely on binaries, environment, or credential files from the kustomize-controller Pod. This matches the constraints of KubeConfigs from current Cluster API providers. KubeConfigs with cmd-path in them likely won't work without a custom, per-provider installation of kustomize-controller. Secrets decryption \u00b6 In order to store secrets safely in a public or private Git repository, you can use Mozilla SOPS and encrypt your Kubernetes Secrets data with OpenPGP keys. Generate a GPG key without passphrase using gnupg then use sops to encrypt a Kubernetes secret: sops --pgp = FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 \\ --encrypt --encrypted-regex '^(data|stringData)$' --in-place my-secret.yaml Commit and push the encrypted file to Git. Note that you should encrypt only the data section, encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. Create a secret in the default namespace with the OpenPGP private key: gpg --export-secret-keys --armor FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 | kubectl -n default create secret generic sops-gpg \\ --from-file = sops.asc = /dev/stdin Configure decryption by referring the private key secret: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets namespace : default spec : interval : 5m path : \"./\" sourceRef : kind : GitRepository name : my-secrets decryption : provider : sops secretRef : name : sops-pgp Status \u00b6 When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-09-17T19:28:48Z\" message : \"Applied revision: master/a1afe267b54f38b46b487f6e938a6fd508278c07\" reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-09-17T07:26:48Z\" message : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error and issues a Kubernetes event: { \"level\" : \"error\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Kustomization CRD"},{"location":"components/kustomize/kustomization/#kustomization","text":"The Kustomization API defines a pipeline for fetching, decrypting, building, validating and applying Kubernetes manifests.","title":"Kustomization"},{"location":"components/kustomize/kustomization/#specification","text":"A Kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice // with references to Kustomization resources that must be ready before this // Kustomization can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Decrypt Kubernetes secrets before applying them on the cluster. // +optional Decryption * Decryption `json:\"decryption,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // The KubeConfig for reconciling the Kustomization on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of resources to be included in the health assessment. // +optional HealthChecks [] CrossNamespaceObjectReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceSourceReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // TargetNamespace sets or overrides the namespace in the // kustomization.yaml file. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The decryption section defines how decryption is handled for Kubernetes manifests: type Decryption struct { // Provider is the name of the decryption engine. // +kubebuilder:validation:Enum=sops // +required Provider string `json:\"provider\"` // The secret name containing the private OpenPGP keys used for decryption. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } KubeConfig references a Kubernetes Secret for applying to another cluster. This can be used with Cluster API: type KubeConfig struct { // SecretRef holds the name to a secret that contains a 'value' key with // the kubeconfig file as the value. It must be in the same namespace as // the Kustomization. // It is recommended that the kubeconfig is self-contained, and the secret // is regularly updated if credentials such as a cloud-access-token expire. // Cloud specific `cmd-path` auth helpers will not function without adding // binaries and credentials to the Pod that is responsible for reconciling // the Kustomization. // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } The status sub-resource records the result of the last reconciliation: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the Kustomization) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition is the name of the condition that // records the readiness status of a Kustomization. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the // reconciliation of the Kustomization has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the // reconciliation of the Kustomization has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // ProgressingReason represents the fact that the // reconciliation of the Kustomization is underway. ProgressingReason string = \"Progressing\" // SuspendedReason represents the fact that the // reconciliation of the Kustomization has been suspended. SuspendedReason string = \"Suspended\" // DependencyNotReady represents the fact that // one of the dependencies of the Kustomization is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // PruneFailedReason represents the fact that the // pruning of the Kustomization failed. PruneFailedReason string = \"PruneFailed\" // ArtifactFailedReason represents the fact that the // artifact download of the kustomization failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the // kustomize build of the Kustomization failed. BuildFailedReason string = \"BuildFailed\" // HealthCheckFailedReason represents the fact that // one of the health checks of the Kustomization failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // ValidationFailedReason represents the fact that the // validation of the Kustomization manifests has failed. ValidationFailedReason string = \"ValidationFailed\" )","title":"Specification"},{"location":"components/kustomize/kustomization/#source-reference","text":"The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Bucket Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your Git repository or S3 bucket contains only plain manifests, then a kustomization.yaml will be automatically generated.","title":"Source reference"},{"location":"components/kustomize/kustomization/#generate-kustomizationyaml","text":"If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection .","title":"Generate kustomization.yaml"},{"location":"components/kustomize/kustomization/#reconciliation","text":"The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"reconcile.fluxcd.io/requestedAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo reconcile.fluxcd.io/requestedAt = \" $( date +%s ) \"","title":"Reconciliation"},{"location":"components/kustomize/kustomization/#garbage-collection","text":"To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster.","title":"Garbage collection"},{"location":"components/kustomize/kustomization/#health-assessment","text":"A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads and the ready status of custom resources. A health check entry can reference one of the following types: Kubernetes builtin kinds: Deployment, DaemonSet, StatefulSet, PersistentVolumeClaim, Pod, PodDisruptionBudget, Job, CronJob, Service, Secret, ConfigMap, CustomResourceDefinition Toolkit kinds: HelmRelease, HelmRepository, GitRepository, etc Custom resources that are compatible with kstatus Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : apps/v1 kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready. When a Kustomization contains HelmRelease objects, instead of checking the underling Deployments, you can define a health check that waits for the HelmReleases to be reconciled with: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : webapp namespace : default spec : interval : 15m path : \"./releases/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : frontend namespace : dev - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : backend namespace : dev timeout : 5m If all the HelmRelease objects are successfully installed or upgraded, then the Kustomization will be marked as ready.","title":"Health assessment"},{"location":"components/kustomize/kustomization/#kustomization-dependencies","text":"When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : common namespace : default spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : dependsOn : - name : common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : istio namespace : istio-system spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : default spec : dependsOn : - name : common - name : istio namespace : istio-system interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster.","title":"Kustomization dependencies"},{"location":"components/kustomize/kustomization/#role-based-access-control","text":"By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend namespace : webapp spec : dependsOn : - name : common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace.","title":"Role-based access control"},{"location":"components/kustomize/kustomization/#remote-clusters-cluster-api","text":"If the kubeConfig field is set, objects will be applied, health-checked, pruned, and deleted for the default cluster specified in that KubeConfig instead of using the in-cluster ServiceAccount. The secret defined in the kubeConfig.SecretRef must exist in the same namespace as the Kustomization. On every reconciliation, the KubeConfig bytes will be loaded from the values key of the secret's data, and the secret can thus be regularly updated if cluster-access-tokens have to rotate due to expiration. This composes well with Cluster API bootstrap providers such as CAPBK (kubeadm) as well as the CAPA (AWS) EKS integration. To reconcile a Kustomization to a CAPI controlled cluster, put the Kustomization in the same namespace as your Cluster object, and set the kubeConfig.secretRef.name to <cluster-name>-kubeconfig : apiVersion : cluster.x-k8s.io/v1alpha3 kind : Cluster metadata : name : stage # the kubeconfig Secret will contain the Cluster name namespace : capi-stage spec : clusterNetwork : pods : cidrBlocks : - 10.100.0.0/16 serviceDomain : stage-cluster.local services : cidrBlocks : - 10.200.0.0/12 controlPlaneRef : apiVersion : controlplane.cluster.x-k8s.io/v1alpha3 kind : KubeadmControlPlane name : stage-control-plane namespace : capi-stage infrastructureRef : apiVersion : infrastructure.cluster.x-k8s.io/v1alpha3 kind : DockerCluster name : stage namespace : capi-stage --- # ... unrelated Cluster API objects omitted for brevity ... --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : cluster-addons namespace : capi-stage spec : interval : 5m path : \"./config/addons/\" prune : true sourceRef : kind : GitRepository name : cluster-addons kubeConfig : secretRef : name : stage-kubeconfig # Cluster API creates this for the matching Cluster The Cluster and Kustomization can be created at the same time. The Kustomization will eventually reconcile once the cluster is available. If you wish to target clusters created by other means than CAPI, you can create a ServiceAccount on the remote cluster, generate a KubeConfig for that account, and then create a secret on the cluster where kustomize-controller is running e.g.: kubectl create secret generic prod-kubeconfig \\ --from-file = value = ./kubeconfig Note that the KubeConfig should be self-contained and not rely on binaries, environment, or credential files from the kustomize-controller Pod. This matches the constraints of KubeConfigs from current Cluster API providers. KubeConfigs with cmd-path in them likely won't work without a custom, per-provider installation of kustomize-controller.","title":"Remote Clusters / Cluster-API"},{"location":"components/kustomize/kustomization/#secrets-decryption","text":"In order to store secrets safely in a public or private Git repository, you can use Mozilla SOPS and encrypt your Kubernetes Secrets data with OpenPGP keys. Generate a GPG key without passphrase using gnupg then use sops to encrypt a Kubernetes secret: sops --pgp = FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 \\ --encrypt --encrypted-regex '^(data|stringData)$' --in-place my-secret.yaml Commit and push the encrypted file to Git. Note that you should encrypt only the data section, encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. Create a secret in the default namespace with the OpenPGP private key: gpg --export-secret-keys --armor FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 | kubectl -n default create secret generic sops-gpg \\ --from-file = sops.asc = /dev/stdin Configure decryption by referring the private key secret: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets namespace : default spec : interval : 5m path : \"./\" sourceRef : kind : GitRepository name : my-secrets decryption : provider : sops secretRef : name : sops-pgp","title":"Secrets decryption"},{"location":"components/kustomize/kustomization/#status","text":"When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-09-17T19:28:48Z\" message : \"Applied revision: master/a1afe267b54f38b46b487f6e938a6fd508278c07\" reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-09-17T07:26:48Z\" message : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error and issues a Kubernetes event: { \"level\" : \"error\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Status"},{"location":"components/notification/alert/","text":"Alert \u00b6 The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching. Specification \u00b6 Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : webapp namespace : default spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Bucket name : secrets - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : all-kustomizations namespace : default spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : default name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Alert CRD"},{"location":"components/notification/alert/#alert","text":"The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching.","title":"Alert"},{"location":"components/notification/alert/#specification","text":"Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/alert/#example","text":"apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : webapp namespace : default spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Bucket name : secrets - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : all-kustomizations namespace : default spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : default name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Example"},{"location":"components/notification/api/","text":"Kustomize API reference Packages: notification.toolkit.fluxcd.io/v1beta1 notification.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the notification v1beta1 API group Resource Types: Alert Provider Receiver Alert Alert is the Schema for the alerts API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Alert metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec AlertSpec providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). If set to \u2018info\u2019 no events will be filtered. eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. status AlertStatus Provider Provider is the Schema for the providers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Provider metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ProviderSpec type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP/S webhook address of this provider proxy string (Optional) HTTP/S address of the proxy secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL status ProviderStatus Receiver Receiver is the Schema for the receivers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Receiver metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ReceiverSpec type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. status ReceiverStatus AlertSpec ( Appears on: Alert ) AlertSpec defines an alerting rule for events involving a list of objects Field Description providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). If set to \u2018info\u2019 no events will be filtered. eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. AlertStatus ( Appears on: Alert ) AlertStatus defines the observed state of Alert Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) CrossNamespaceObjectReference ( Appears on: AlertSpec , ReceiverSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent ProviderSpec ( Appears on: Provider ) ProviderSpec defines the desired state of Provider Field Description type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP/S webhook address of this provider proxy string (Optional) HTTP/S address of the proxy secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL ProviderStatus ( Appears on: Provider ) ProviderStatus defines the observed state of Provider Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) ReceiverSpec ( Appears on: Receiver ) ReceiverSpec defines the desired state of Receiver Field Description type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. ReceiverStatus ( Appears on: Receiver ) ReceiverStatus defines the observed state of Receiver Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) url string (Optional) Generated webhook URL in the format of \u2018/hook/sha256sum(token+name+namespace)\u2019. This page was automatically generated with gen-crd-api-reference-docs","title":"Notification API Reference"},{"location":"components/notification/controller/","text":"Notification Controller \u00b6 The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Overview"},{"location":"components/notification/controller/#notification-controller","text":"The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Notification Controller"},{"location":"components/notification/event/","text":"Event \u00b6 The Event API defines what information a report of an event issued by a controller should contain. Specification \u00b6 Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/runtime/events package to push events to notification-controller API.","title":"Event"},{"location":"components/notification/event/#event","text":"The Event API defines what information a report of an event issued by a controller should contain.","title":"Event"},{"location":"components/notification/event/#specification","text":"Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/runtime/events package to push events to notification-controller API.","title":"Specification"},{"location":"components/notification/provider/","text":"Provider \u00b6 The Provider API defines how events are encoded and the webhook address where they are dispatched. Specification \u00b6 Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic;github;gitlab // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP/S webhook address of this provider // +kubebuilder:validation:Pattern=\"^(http|https)://\" // +optional Address string `json:\"address,omitempty\"` // HTTP/S address of the proxy // +kubebuilder:validation:Pattern=\"^(http|https)://\" // +optional Proxy string `json:\"proxy,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Git commit status providers: GitHub GitLab Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 Notifications \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : default spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # HTTP(S) proxy (optional) proxy : https://proxy.corp:8080 # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord , github or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. Git commit status \u00b6 The GitHub/GitLab provider is a special kind of notification provider that based on the state of a Kustomization resource, will update the commit status for the currently reconciled commit id. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : default spec : # provider type can be github or gitlab type : github address : https://github.com/stefanprodan/podinfo secretRef : name : git-api-token The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub or GitLab API. kubectl create secret generic git-api-token \\ --from-literal = token = YOUR-TOKEN","title":"Provider CRD"},{"location":"components/notification/provider/#provider","text":"The Provider API defines how events are encoded and the webhook address where they are dispatched.","title":"Provider"},{"location":"components/notification/provider/#specification","text":"Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic;github;gitlab // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP/S webhook address of this provider // +kubebuilder:validation:Pattern=\"^(http|https)://\" // +optional Address string `json:\"address,omitempty\"` // HTTP/S address of the proxy // +kubebuilder:validation:Pattern=\"^(http|https)://\" // +optional Proxy string `json:\"proxy,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Git commit status providers: GitHub GitLab Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/provider/#example","text":"","title":"Example"},{"location":"components/notification/provider/#notifications","text":"apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : default spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # HTTP(S) proxy (optional) proxy : https://proxy.corp:8080 # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord , github or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address.","title":"Notifications"},{"location":"components/notification/provider/#git-commit-status","text":"The GitHub/GitLab provider is a special kind of notification provider that based on the state of a Kustomization resource, will update the commit status for the currently reconciled commit id. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : default spec : # provider type can be github or gitlab type : github address : https://github.com/stefanprodan/podinfo secretRef : name : git-api-token The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub or GitLab API. kubectl create secret generic git-api-token \\ --from-literal = token = YOUR-TOKEN","title":"Git commit status"},{"location":"components/notification/receiver/","text":"Receiver \u00b6 The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources. Specification \u00b6 type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" ) Status \u00b6 type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` } Example \u00b6 Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : default spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : default spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : default spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : default spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : default spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp - kind : Bucket name : secrets When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Receiver CRD"},{"location":"components/notification/receiver/#receiver","text":"The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources.","title":"Receiver"},{"location":"components/notification/receiver/#specification","text":"type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" )","title":"Specification"},{"location":"components/notification/receiver/#status","text":"type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` }","title":"Status"},{"location":"components/notification/receiver/#example","text":"Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : default spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : default spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : default spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : default spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : default spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp - kind : Bucket name : secrets When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Example"},{"location":"components/source/api/","text":"Source API reference Packages: source.toolkit.fluxcd.io/v1beta1 source.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the source v1beta1 API group Resource Types: Bucket GitRepository HelmChart HelmRepository Bucket Bucket is the Schema for the buckets API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string Bucket metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec BucketSpec provider string (Optional) The S3 compatible storage provider name, default (\u2018generic\u2019). bucketName string The bucket name. endpoint string The bucket endpoint address. insecure bool (Optional) Insecure allows connecting to a non-TLS S3 HTTP endpoint. region string (Optional) The bucket region. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Bucket. interval Kubernetes meta/v1.Duration The interval at which to check for bucket updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for download operations, defaults to 20s. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. status BucketStatus GitRepository GitRepository is the Schema for the gitrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string GitRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GitRepositorySpec url string The repository URL, can be a HTTP/S or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote Git operations like cloning, defaults to 20s. ref GitRepositoryRef (Optional) The Git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the Git commit HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. status GitRepositoryStatus HelmChart HelmChart is the Schema for the helmcharts API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string HelmChart metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmChartSpec chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted. sourceRef LocalHelmChartSourceReference The reference to the Source the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Source for updates. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. status HelmChartStatus HelmRepository HelmRepository is the Schema for the helmrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string HelmRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmRepositorySpec url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. status HelmRepositoryStatus Artifact ( Appears on: BucketStatus , GitRepositoryStatus , HelmChartStatus , HelmRepositoryStatus ) Artifact represents the output of a source synchronisation. Field Description path string Path is the relative file path of this artifact. url string URL is the HTTP address of this artifact. revision string (Optional) Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc. checksum string (Optional) Checksum is the SHA1 checksum of the artifact. lastUpdateTime Kubernetes meta/v1.Time LastUpdateTime is the timestamp corresponding to the last update of this artifact. BucketSpec ( Appears on: Bucket ) BucketSpec defines the desired state of an S3 compatible bucket Field Description provider string (Optional) The S3 compatible storage provider name, default (\u2018generic\u2019). bucketName string The bucket name. endpoint string The bucket endpoint address. insecure bool (Optional) Insecure allows connecting to a non-TLS S3 HTTP endpoint. region string (Optional) The bucket region. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Bucket. interval Kubernetes meta/v1.Duration The interval at which to check for bucket updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for download operations, defaults to 20s. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. BucketStatus ( Appears on: Bucket ) BucketStatus defines the observed state of a bucket Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the Bucket. url string (Optional) URL is the download link for the artifact output of the last Bucket sync. artifact Artifact (Optional) Artifact represents the output of the last successful Bucket sync. GitRepositoryRef ( Appears on: GitRepositorySpec ) GitRepositoryRef defines the Git ref used for pull and checkout operations. Field Description branch string (Optional) The Git branch to checkout, defaults to master. tag string (Optional) The Git tag to checkout, takes precedence over Branch. semver string (Optional) The Git tag semver expression, takes precedence over Tag. commit string (Optional) The Git commit SHA to checkout, if specified Tag filters will be ignored. GitRepositorySpec ( Appears on: GitRepository ) GitRepositorySpec defines the desired state of a Git repository. Field Description url string The repository URL, can be a HTTP/S or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote Git operations like cloning, defaults to 20s. ref GitRepositoryRef (Optional) The Git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the Git commit HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. GitRepositoryStatus ( Appears on: GitRepository ) GitRepositoryStatus defines the observed state of a Git repository. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the GitRepository. url string (Optional) URL is the download link for the artifact output of the last repository sync. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. GitRepositoryVerification ( Appears on: GitRepositorySpec ) GitRepositoryVerification defines the OpenPGP signature verification process. Field Description mode string Mode describes what git object should be verified, currently (\u2018head\u2019). secretRef Kubernetes core/v1.LocalObjectReference The secret name containing the public keys of all trusted Git authors. HelmChartSpec ( Appears on: HelmChart ) HelmChartSpec defines the desired state of a Helm chart. Field Description chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted. sourceRef LocalHelmChartSourceReference The reference to the Source the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Source for updates. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmChartStatus ( Appears on: HelmChart ) HelmChartStatus defines the observed state of the HelmChart. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmChart. url string (Optional) URL is the download link for the last chart pulled. artifact Artifact (Optional) Artifact represents the output of the last successful chart sync. HelmRepositorySpec ( Appears on: HelmRepository ) HelmRepositorySpec defines the reference to a Helm repository. Field Description url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. HelmRepositoryStatus ( Appears on: HelmRepository ) HelmRepositoryStatus defines the observed state of the HelmRepository. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmRepository. url string (Optional) URL is the download link for the last index fetched. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. LocalHelmChartSourceReference ( Appears on: HelmChartSpec ) LocalHelmChartSourceReference contains enough information to let you locate the typed referenced object at namespace level. Field Description apiVersion string (Optional) APIVersion of the referent. kind string Kind of the referent, valid values are (\u2018HelmRepository\u2019, \u2018GitRepository\u2019, \u2018Bucket\u2019). name string Name of the referent. Source Source interface must be supported by all API types. This page was automatically generated with gen-crd-api-reference-docs","title":"Source API Reference"},{"location":"components/source/buckets/","text":"Object storage buckets \u00b6 The Bucket API defines a source for artifacts coming from S3 compatible storage such as Minio, Amazon S3, Google Cloud Storage, Alibaba Cloud OSS and others. Specification \u00b6 Bucket: // BucketSpec defines the desired state of an S3 compatible bucket type BucketSpec struct { // The S3 compatible storage provider name, default ('generic'). // +kubebuilder:validation:Enum=generic;aws // +optional Provider string `json:\"provider,omitempty\"` // The bucket name. // +required BucketName string `json:\"bucketName\"` // The bucket endpoint address. // +required Endpoint string `json:\"endpoint\"` // Insecure allows connecting to a non-TLS S3 HTTP endpoint. // +optional Insecure bool `json:\"insecure,omitempty\"` // The bucket region. // +optional Region string `json:\"region,omitempty\"` // The name of the secret containing authentication credentials // for the Bucket. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for bucket updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for download operations, defaults to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Supported providers: const ( GenericBucketProvider string = \"generic\" AmazonBucketProvider string = \"aws\" ) Status \u00b6 // BucketStatus defines the observed state of a bucket type BucketStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the Bucket. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last Bucket sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful Bucket sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // BucketOperationSucceedReason represents the fact that the bucket listing and // download operations succeeded. BucketOperationSucceedReason string = \"BucketOperationSucceed\" // BucketOperationFailedReason represents the fact that the bucket listing or // download operations failed. BucketOperationFailedReason string = \"BucketOperationFailed\" ) Artifact \u00b6 The resource exposes the latest synchronized state from S3 as an artifact in a gzip compressed TAR archive ( <bucket checksum>.tar.gz ). Excluding files \u00b6 Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the bucket. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list. Spec examples \u00b6 Static authentication \u00b6 Authentication credentials can be provided with a Kubernetes secret that contains accesskey and secretkey fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 insecure : true secretRef : name : minio-credentials --- apiVersion : v1 kind : Secret metadata : name : minio-credentials namespace : default type : Opaque data : accesskey : <BASE64> secretkey : <BASE64> Note: that for Google Cloud Storage you have to enable S3 compatible access in your GCP project. AWS IAM authentication \u00b6 When the provider is aws and the secretRef is not specified, the credentials are retrieve from the EC2 service: apiVersion : source.toolkit.fluccd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : interval : 5m provider : aws bucketName : podinfo endpoint : s3.amazonaws.com region : us-east-1 timeout : 30s Note: that on EKS you have to create an IAM role for the source-controller service account that grants access to the bucket. Status examples \u00b6 Successful download: status : artifact : checksum : b249024b8544521792a079c4037d0a06dd0497a9 lastUpdateTime : \"2020-09-18T08:34:49Z\" path : bucket/source-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz revision : aeaba8b6dd51c53084f99b098cfae4f5148ad410 url : http://localhost:9090/bucket/source-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : 'Fetched revision: aeaba8b6dd51c53084f99b098cfae4f5148ad410' reason : BucketOperationSucceed status : \"True\" type : Ready observedGeneration : 2 url : http://localhost:9090/bucket/source-system/podinfo/latest.tar.gz Failed download: status : conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : \"bucket 'test' not found\" reason : BucketOperationFailed status : \"False\" type : Ready Wait for ready condition: kubectl -n gitios-system wait bucket/podinfo --for = condition = ready --timeout = 1m","title":"Bucket CRD"},{"location":"components/source/buckets/#object-storage-buckets","text":"The Bucket API defines a source for artifacts coming from S3 compatible storage such as Minio, Amazon S3, Google Cloud Storage, Alibaba Cloud OSS and others.","title":"Object storage buckets"},{"location":"components/source/buckets/#specification","text":"Bucket: // BucketSpec defines the desired state of an S3 compatible bucket type BucketSpec struct { // The S3 compatible storage provider name, default ('generic'). // +kubebuilder:validation:Enum=generic;aws // +optional Provider string `json:\"provider,omitempty\"` // The bucket name. // +required BucketName string `json:\"bucketName\"` // The bucket endpoint address. // +required Endpoint string `json:\"endpoint\"` // Insecure allows connecting to a non-TLS S3 HTTP endpoint. // +optional Insecure bool `json:\"insecure,omitempty\"` // The bucket region. // +optional Region string `json:\"region,omitempty\"` // The name of the secret containing authentication credentials // for the Bucket. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for bucket updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for download operations, defaults to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Supported providers: const ( GenericBucketProvider string = \"generic\" AmazonBucketProvider string = \"aws\" )","title":"Specification"},{"location":"components/source/buckets/#status","text":"// BucketStatus defines the observed state of a bucket type BucketStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the Bucket. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last Bucket sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful Bucket sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/buckets/#condition-reasons","text":"const ( // BucketOperationSucceedReason represents the fact that the bucket listing and // download operations succeeded. BucketOperationSucceedReason string = \"BucketOperationSucceed\" // BucketOperationFailedReason represents the fact that the bucket listing or // download operations failed. BucketOperationFailedReason string = \"BucketOperationFailed\" )","title":"Condition reasons"},{"location":"components/source/buckets/#artifact","text":"The resource exposes the latest synchronized state from S3 as an artifact in a gzip compressed TAR archive ( <bucket checksum>.tar.gz ).","title":"Artifact"},{"location":"components/source/buckets/#excluding-files","text":"Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the bucket. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list.","title":"Excluding files"},{"location":"components/source/buckets/#spec-examples","text":"","title":"Spec examples"},{"location":"components/source/buckets/#static-authentication","text":"Authentication credentials can be provided with a Kubernetes secret that contains accesskey and secretkey fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 insecure : true secretRef : name : minio-credentials --- apiVersion : v1 kind : Secret metadata : name : minio-credentials namespace : default type : Opaque data : accesskey : <BASE64> secretkey : <BASE64> Note: that for Google Cloud Storage you have to enable S3 compatible access in your GCP project.","title":"Static authentication"},{"location":"components/source/buckets/#aws-iam-authentication","text":"When the provider is aws and the secretRef is not specified, the credentials are retrieve from the EC2 service: apiVersion : source.toolkit.fluccd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : default spec : interval : 5m provider : aws bucketName : podinfo endpoint : s3.amazonaws.com region : us-east-1 timeout : 30s Note: that on EKS you have to create an IAM role for the source-controller service account that grants access to the bucket.","title":"AWS IAM authentication"},{"location":"components/source/buckets/#status-examples","text":"Successful download: status : artifact : checksum : b249024b8544521792a079c4037d0a06dd0497a9 lastUpdateTime : \"2020-09-18T08:34:49Z\" path : bucket/source-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz revision : aeaba8b6dd51c53084f99b098cfae4f5148ad410 url : http://localhost:9090/bucket/source-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : 'Fetched revision: aeaba8b6dd51c53084f99b098cfae4f5148ad410' reason : BucketOperationSucceed status : \"True\" type : Ready observedGeneration : 2 url : http://localhost:9090/bucket/source-system/podinfo/latest.tar.gz Failed download: status : conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : \"bucket 'test' not found\" reason : BucketOperationFailed status : \"False\" type : Ready Wait for ready condition: kubectl -n gitios-system wait bucket/podinfo --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/controller/","text":"Source Controller \u00b6 The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Overview"},{"location":"components/source/controller/#source-controller","text":"The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Source Controller"},{"location":"components/source/gitrepositories/","text":"Git Repositories \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive . Specification \u00b6 Git repository: // GitRepositorySpec defines the desired state of a Git repository. type GitRepositorySpec struct { // The repository URL, can be a HTTP/S or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" // +required URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for remote Git operations like cloning, defaults to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The Git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the Git commit HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the Git ref used for pull and checkout operations. type GitRepositoryRef struct { // The Git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The Git tag to checkout, takes precedence over Branch. // +optional Tag string `json:\"tag,omitempty\"` // The Git tag semver expression, takes precedence over Tag. // +optional SemVer string `json:\"semver,omitempty\"` // The Git commit SHA to checkout, if specified Tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted Git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Status \u00b6 // GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // Conditions holds the conditions for the GitRepository. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" ) Artifact \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ). Excluding files \u00b6 Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list. Spec examples \u00b6 Checkout strategies \u00b6 Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\" HTTPS authentication \u00b6 HTTPS authentication requires a Kubernetes secret with username and password fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> Note: that self-signed certificates are not supported. SSH authentication \u00b6 SSH authentication requires a Kubernetes secret with identity and known_hosts fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts GPG signature verification \u00b6 Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc Status examples \u00b6 Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"GitRepository CRD"},{"location":"components/source/gitrepositories/#git-repositories","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive .","title":"Git Repositories"},{"location":"components/source/gitrepositories/#specification","text":"Git repository: // GitRepositorySpec defines the desired state of a Git repository. type GitRepositorySpec struct { // The repository URL, can be a HTTP/S or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" // +required URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for remote Git operations like cloning, defaults to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The Git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the Git commit HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the Git ref used for pull and checkout operations. type GitRepositoryRef struct { // The Git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The Git tag to checkout, takes precedence over Branch. // +optional Tag string `json:\"tag,omitempty\"` // The Git tag semver expression, takes precedence over Tag. // +optional SemVer string `json:\"semver,omitempty\"` // The Git commit SHA to checkout, if specified Tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted Git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` }","title":"Specification"},{"location":"components/source/gitrepositories/#status","text":"// GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // Conditions holds the conditions for the GitRepository. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/gitrepositories/#condition-reasons","text":"const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" )","title":"Condition reasons"},{"location":"components/source/gitrepositories/#artifact","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ).","title":"Artifact"},{"location":"components/source/gitrepositories/#excluding-files","text":"Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list.","title":"Excluding files"},{"location":"components/source/gitrepositories/#spec-examples","text":"","title":"Spec examples"},{"location":"components/source/gitrepositories/#checkout-strategies","text":"Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\"","title":"Checkout strategies"},{"location":"components/source/gitrepositories/#https-authentication","text":"HTTPS authentication requires a Kubernetes secret with username and password fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> Note: that self-signed certificates are not supported.","title":"HTTPS authentication"},{"location":"components/source/gitrepositories/#ssh-authentication","text":"SSH authentication requires a Kubernetes secret with identity and known_hosts fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts","title":"SSH authentication"},{"location":"components/source/gitrepositories/#gpg-signature-verification","text":"Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : default spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc","title":"GPG signature verification"},{"location":"components/source/gitrepositories/#status-examples","text":"Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmcharts/","text":"Helm Charts \u00b6 The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled or packaged chart as an artifact. Specification \u00b6 Helm chart: // HelmChartSpec defines the desired state of a Helm chart. type HelmChartSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // The chart version semver expression, ignored for charts from GitRepository // and Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The reference to the Source the chart is available at. // +required SourceRef LocalHelmChartSourceReference `json:\"sourceRef\"` // The interval at which to check the Source for updates. // +required Interval metav1 . Duration `json:\"interval\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } Reference types \u00b6 // LocalHelmChartSourceReference contains enough information to let you locate // the typed referenced object at namespace level. type LocalHelmChartSourceReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent, valid values are ('HelmRepository', 'GitRepository', // 'Bucket'). // +kubebuilder:validation:Enum=HelmRepository;GitRepository;Bucket // +required Kind string `json:\"kind\"` // Name of the referent. // +required Name string `json:\"name\"` } Status \u00b6 // HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the HelmChart. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last chart pulled. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // ChartPullFailedReason represents the fact that the pull of the Helm chart // failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of the Helm chart // succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" // ChartPackageFailedReason represent the fact that the package of the Helm // chart failed. ChartPackageFailedReason string = \"ChartPackageFailed\" // ChartPackageSucceededReason represents the fact that the package of the Helm // chart succeeded. ChartPackageSucceededReason string = \"ChartPackageSucceeded\" ) Spec examples \u00b6 Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis namespace : default spec : chart : redis version : 10.5.7 sourceRef : name : stable kind : HelmRepository interval : 5m Pull the latest chart version that matches the semver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis namespace : default spec : chart : redis version : 10.5.x sourceRef : name : stable kind : HelmRepository interval : 10m Check a Git repository every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo namespace : default spec : chart : ./charts/podinfo sourceRef : name : podinfo kind : GitRepository interval : 10m Check a S3 compatible bucket every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo namespace : default spec : chart : ./podinfo sourceRef : name : charts kind : Bucket interval : 10m Status examples \u00b6 Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"HelmChart CRD"},{"location":"components/source/helmcharts/#helm-charts","text":"The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled or packaged chart as an artifact.","title":"Helm Charts"},{"location":"components/source/helmcharts/#specification","text":"Helm chart: // HelmChartSpec defines the desired state of a Helm chart. type HelmChartSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // The chart version semver expression, ignored for charts from GitRepository // and Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The reference to the Source the chart is available at. // +required SourceRef LocalHelmChartSourceReference `json:\"sourceRef\"` // The interval at which to check the Source for updates. // +required Interval metav1 . Duration `json:\"interval\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` }","title":"Specification"},{"location":"components/source/helmcharts/#reference-types","text":"// LocalHelmChartSourceReference contains enough information to let you locate // the typed referenced object at namespace level. type LocalHelmChartSourceReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent, valid values are ('HelmRepository', 'GitRepository', // 'Bucket'). // +kubebuilder:validation:Enum=HelmRepository;GitRepository;Bucket // +required Kind string `json:\"kind\"` // Name of the referent. // +required Name string `json:\"name\"` }","title":"Reference types"},{"location":"components/source/helmcharts/#status","text":"// HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the HelmChart. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last chart pulled. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmcharts/#condition-reasons","text":"const ( // ChartPullFailedReason represents the fact that the pull of the Helm chart // failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of the Helm chart // succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" // ChartPackageFailedReason represent the fact that the package of the Helm // chart failed. ChartPackageFailedReason string = \"ChartPackageFailed\" // ChartPackageSucceededReason represents the fact that the package of the Helm // chart succeeded. ChartPackageSucceededReason string = \"ChartPackageSucceeded\" )","title":"Condition reasons"},{"location":"components/source/helmcharts/#spec-examples","text":"Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis namespace : default spec : chart : redis version : 10.5.7 sourceRef : name : stable kind : HelmRepository interval : 5m Pull the latest chart version that matches the semver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis namespace : default spec : chart : redis version : 10.5.x sourceRef : name : stable kind : HelmRepository interval : 10m Check a Git repository every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo namespace : default spec : chart : ./charts/podinfo sourceRef : name : podinfo kind : GitRepository interval : 10m Check a S3 compatible bucket every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo namespace : default spec : chart : ./podinfo sourceRef : name : charts kind : Bucket interval : 10m","title":"Spec examples"},{"location":"components/source/helmcharts/#status-examples","text":"Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmrepositories/","text":"Helm Repositories \u00b6 The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact. Specification \u00b6 Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials for the Helm // repository. // For HTTP/S basic auth the secret must contain username and // password fields. // For TLS the secret must contain a certFile and keyFile, and/or // caCert fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` } Status \u00b6 // HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the HelmRepository. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // IndexationFailedReason represents the fact that the indexation of the given // Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation of the // given Helm repository succeeded. IndexationSucceededReason string = \"IndexationSucceed\" ) Spec examples \u00b6 Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable namespace : default spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : private namespace : default spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64> Status examples \u00b6 Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"HelmRepository CRD"},{"location":"components/source/helmrepositories/#helm-repositories","text":"The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact.","title":"Helm Repositories"},{"location":"components/source/helmrepositories/#specification","text":"Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials for the Helm // repository. // For HTTP/S basic auth the secret must contain username and // password fields. // For TLS the secret must contain a certFile and keyFile, and/or // caCert fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` }","title":"Specification"},{"location":"components/source/helmrepositories/#status","text":"// HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the HelmRepository. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmrepositories/#condition-reasons","text":"const ( // IndexationFailedReason represents the fact that the indexation of the given // Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation of the // given Helm repository succeeded. IndexationSucceededReason string = \"IndexationSucceed\" )","title":"Condition reasons"},{"location":"components/source/helmrepositories/#spec-examples","text":"Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable namespace : default spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : private namespace : default spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64>","title":"Spec examples"},{"location":"components/source/helmrepositories/#status-examples","text":"Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"contributing/","text":"Contributing \u00b6 Flux is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code. Certificate of Origin \u00b6 By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization. Communications \u00b6 For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ). Understanding Flux and the GitOps Toolkit \u00b6 If you are entirely new to Flux and the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/flux2 : The Flux CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events Understanding the code \u00b6 To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes. How to run the test suite \u00b6 You can run the unit tests by simply doing make test Acceptance policy \u00b6 These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR. Format of the Commit Message \u00b6 For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Contributing"},{"location":"contributing/#contributing","text":"Flux is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code.","title":"Contributing"},{"location":"contributing/#certificate-of-origin","text":"By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization.","title":"Certificate of Origin"},{"location":"contributing/#communications","text":"For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ).","title":"Communications"},{"location":"contributing/#understanding-flux-and-the-gitops-toolkit","text":"If you are entirely new to Flux and the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/flux2 : The Flux CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events","title":"Understanding Flux and the GitOps Toolkit"},{"location":"contributing/#understanding-the-code","text":"To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes.","title":"Understanding the code"},{"location":"contributing/#how-to-run-the-test-suite","text":"You can run the unit tests by simply doing make test","title":"How to run the test suite"},{"location":"contributing/#acceptance-policy","text":"These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR.","title":"Acceptance policy"},{"location":"contributing/#format-of-the-commit-message","text":"For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Format of the Commit Message"},{"location":"dev-guides/source-watcher/","text":"Watching for source changes \u00b6 In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller . Prerequisites \u00b6 On your dev machine install the following tools: go >= 1.15 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03 Install the GitOps Toolkit \u00b6 Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: flux check --pre Install the toolkit controllers on the dev cluster: flux install Clone the sample controller \u00b6 You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make Run the controller \u00b6 Port forward to source-controller artifacts server: kubectl -n flux-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: flux create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"flux-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: flux create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"flux-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> . How it works \u00b6 The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1beta1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#watching-for-source-changes","text":"In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller .","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#prerequisites","text":"On your dev machine install the following tools: go >= 1.15 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03","title":"Prerequisites"},{"location":"dev-guides/source-watcher/#install-the-gitops-toolkit","text":"Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: flux check --pre Install the toolkit controllers on the dev cluster: flux install","title":"Install the GitOps Toolkit"},{"location":"dev-guides/source-watcher/#clone-the-sample-controller","text":"You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make","title":"Clone the sample controller"},{"location":"dev-guides/source-watcher/#run-the-controller","text":"Port forward to source-controller artifacts server: kubectl -n flux-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: flux create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"flux-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: flux create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"flux-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> .","title":"Run the controller"},{"location":"dev-guides/source-watcher/#how-it-works","text":"The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1beta1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"How it works"},{"location":"faq/","text":"Frequently asked questions \u00b6 General questions \u00b6 What does Flux v2 mean for Flux? \u00b6 Flux v1 is a monolithic do-it-all operator; Flux v2 separates the functionalities into specialized controllers, collectively called the GitOps Toolkit. You can install and operate Flux v2 simply using the flux command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on the Flux v2 roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated into Flux v2 and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported. Why did you rewrite Flux? \u00b6 Flux v2 implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build Flux v2 with the top Flux v1 feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the individual components and understanding the codebase becomes a lot easier. What are significant new differences between Flux v1 and Flux v2? \u00b6 Reconciliation \u00b6 Flux v1 Flux v2 Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys kustomize support \u00b6 Flux v1 Flux v2 Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands Helm integration \u00b6 Flux v1 Flux v2 Declarative config in a single Helm custom resource Declarative config through HelmRepository , GitRepository , Bucket , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance Chart changes from Git sources are determined from Git metadata Chart changes must be accompanied by a version bump in Chart.yaml to produce a new artifact Notifications, webhooks, observability \u00b6 Flux v1 Flux v2 Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for included custom resources RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Flux v2 components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics How can I get involved? \u00b6 There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of Flux v2 with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap for Flux v2 Are there any breaking changes? \u00b6 In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance. Is the GitOps Toolkit related to the GitOps Engine? \u00b6 In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq/#general-questions","text":"","title":"General questions"},{"location":"faq/#what-does-flux-v2-mean-for-flux","text":"Flux v1 is a monolithic do-it-all operator; Flux v2 separates the functionalities into specialized controllers, collectively called the GitOps Toolkit. You can install and operate Flux v2 simply using the flux command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on the Flux v2 roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated into Flux v2 and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported.","title":"What does Flux v2 mean for Flux?"},{"location":"faq/#why-did-you-rewrite-flux","text":"Flux v2 implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build Flux v2 with the top Flux v1 feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the individual components and understanding the codebase becomes a lot easier.","title":"Why did you rewrite Flux?"},{"location":"faq/#what-are-significant-new-differences-between-flux-v1-and-flux-v2","text":"","title":"What are significant new differences between Flux v1 and Flux v2?"},{"location":"faq/#reconciliation","text":"Flux v1 Flux v2 Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys","title":"Reconciliation"},{"location":"faq/#kustomize-support","text":"Flux v1 Flux v2 Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands","title":"kustomize support"},{"location":"faq/#helm-integration","text":"Flux v1 Flux v2 Declarative config in a single Helm custom resource Declarative config through HelmRepository , GitRepository , Bucket , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance Chart changes from Git sources are determined from Git metadata Chart changes must be accompanied by a version bump in Chart.yaml to produce a new artifact","title":"Helm integration"},{"location":"faq/#notifications-webhooks-observability","text":"Flux v1 Flux v2 Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for included custom resources RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Flux v2 components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics","title":"Notifications, webhooks, observability"},{"location":"faq/#how-can-i-get-involved","text":"There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of Flux v2 with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap for Flux v2","title":"How can I get involved?"},{"location":"faq/#are-there-any-breaking-changes","text":"In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance.","title":"Are there any breaking changes?"},{"location":"faq/#is-the-gitops-toolkit-related-to-the-gitops-engine","text":"In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"Is the GitOps Toolkit related to the GitOps Engine?"},{"location":"get-started/","text":"Get started with Flux v2 \u00b6 Prerequisites \u00b6 You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username> Install the Flux CLI \u00b6 To install the latest flux release on MacOS and Linux using Homebrew run: brew install fluxcd/tap/flux Or install flux by downloading precompiled binaries using a Bash script: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the flux binary to /usr/local/bin . Binaries for macOS , Windows and Linux AMD64/ARM are available for download on the release page . To configure your shell to load flux completions add to your Bash profile: # ~/.bashrc or ~/.bash_profile . < ( flux completion bash ) zsh , fish , and powershell are also supported with their own sub-commands. GitOps workflow \u00b6 You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the Flux CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production) Staging bootstrap \u00b6 Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ flux check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: flux bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --branch = main \\ --path = staging-cluster \\ --personal ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. The bootstrap command creates a repository if one doesn't exist, and commits the manifests for the Flux components to the default branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: flux bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --branch = <organization default branch> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ flux bootstrap github --owner = gitopsrun --repository = fleet-infra --path = staging-cluster --team = devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in flux-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"helm-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command flux bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the Flux components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific Flux version with flux bootstrap --version=<semver> . Staging workflow \u00b6 Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: flux create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: flux create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: flux create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch flux get kustomizations NAME READY MESSAGE flux-system True Applied revision: main/6eea299fe9997c8561b826b67950afaf9a476cf8 webapp-backend False dependency 'flux-system/webapp-common' is not ready webapp-common True Applied revision: master/7411da595c25183daba255068814b83843fe3395 webapp-frontend False dependency 'flux-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with flux suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with flux resume kustomization <name> . Production bootstrap \u00b6 On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: flux bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull Production workflow \u00b6 Create a git source using a semver range to target stable releases: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: flux create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ flux get sources git NAME REVISION READY MESSAGE flux-system main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 True Fetched revision: main/113360052b3153e439a0cf8de76b8e3d2a7bdf27 webapp 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 True Fetched revision: 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n flux-system get gitrepositories . List kustomization: $ flux get kustomizations NAME REVISION SUSPENDED READY MESSAGE flux-system main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 False True Applied revision: main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 webapp 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 False True Applied revision: 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n flux-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ flux reconcile ks flux-system --with-source \u25ba annotating source flux-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision main/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision main/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n flux-system annotate gitrepository/flux-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch flux get kustomizations NAME REVISION SUSPENDED READY MESSAGE flux-system main/d751ea264d48bf0db8b588d1d08184834ac8fec9 False True Applied revision: main/d751ea264d48bf0db8b588d1d08184834ac8fec9 webapp 4.0.6/26a630c0b4b3452833d96c511d93f6f2d2e90a99 False True Applied revision: 4.0.6/26a630c0b4b3452833d96c511d93f6f2d2e90a99","title":"Get Started"},{"location":"get-started/#get-started-with-flux-v2","text":"","title":"Get started with Flux v2"},{"location":"get-started/#prerequisites","text":"You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username>","title":"Prerequisites"},{"location":"get-started/#install-the-flux-cli","text":"To install the latest flux release on MacOS and Linux using Homebrew run: brew install fluxcd/tap/flux Or install flux by downloading precompiled binaries using a Bash script: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the flux binary to /usr/local/bin . Binaries for macOS , Windows and Linux AMD64/ARM are available for download on the release page . To configure your shell to load flux completions add to your Bash profile: # ~/.bashrc or ~/.bash_profile . < ( flux completion bash ) zsh , fish , and powershell are also supported with their own sub-commands.","title":"Install the Flux CLI"},{"location":"get-started/#gitops-workflow","text":"You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the Flux CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production)","title":"GitOps workflow"},{"location":"get-started/#staging-bootstrap","text":"Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ flux check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: flux bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --branch = main \\ --path = staging-cluster \\ --personal ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. The bootstrap command creates a repository if one doesn't exist, and commits the manifests for the Flux components to the default branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: flux bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --branch = <organization default branch> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ flux bootstrap github --owner = gitopsrun --repository = fleet-infra --path = staging-cluster --team = devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in flux-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"helm-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command flux bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the Flux components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific Flux version with flux bootstrap --version=<semver> .","title":"Staging bootstrap"},{"location":"get-started/#staging-workflow","text":"Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: flux create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: flux create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: flux create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch flux get kustomizations NAME READY MESSAGE flux-system True Applied revision: main/6eea299fe9997c8561b826b67950afaf9a476cf8 webapp-backend False dependency 'flux-system/webapp-common' is not ready webapp-common True Applied revision: master/7411da595c25183daba255068814b83843fe3395 webapp-frontend False dependency 'flux-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with flux suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with flux resume kustomization <name> .","title":"Staging workflow"},{"location":"get-started/#production-bootstrap","text":"On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: flux bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull","title":"Production bootstrap"},{"location":"get-started/#production-workflow","text":"Create a git source using a semver range to target stable releases: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: flux create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ flux get sources git NAME REVISION READY MESSAGE flux-system main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 True Fetched revision: main/113360052b3153e439a0cf8de76b8e3d2a7bdf27 webapp 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 True Fetched revision: 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n flux-system get gitrepositories . List kustomization: $ flux get kustomizations NAME REVISION SUSPENDED READY MESSAGE flux-system main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 False True Applied revision: main/5ae055e24b2c8a78f981708b61507a97a30bd7a6 webapp 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 False True Applied revision: 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n flux-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: flux create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ flux reconcile ks flux-system --with-source \u25ba annotating source flux-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision main/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision main/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n flux-system annotate gitrepository/flux-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch flux get kustomizations NAME REVISION SUSPENDED READY MESSAGE flux-system main/d751ea264d48bf0db8b588d1d08184834ac8fec9 False True Applied revision: main/d751ea264d48bf0db8b588d1d08184834ac8fec9 webapp 4.0.6/26a630c0b4b3452833d96c511d93f6f2d2e90a99 False True Applied revision: 4.0.6/26a630c0b4b3452833d96c511d93f6f2d2e90a99","title":"Production workflow"},{"location":"guides/flux-v1-migration/","text":"Migrate from Flux v1 to v2 \u00b6 This guide walks you through migrating from Flux v1 to v2. Read the FAQ to find out what differences are between v1 and v2. Automated image updates The image automation feature is under development in Flux v2. Please consult the roadmap for more details. Prerequisites \u00b6 You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer. Install Flux v2 CLI \u00b6 With Homebrew: brew install fluxcd/tap/flux With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( flux completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS, Windows and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: flux check --pre GitOps migration \u00b6 Flux v2 offers an installation procedure that is declarative first and disaster resilient. Using the flux bootstrap command you can install Flux on a Kubernetes cluster and configure it to manage itself from a Git repository. The Git repository created during bootstrap can be used to define the state of your fleet of Kubernetes clusters. For a detailed walk-through of the bootstrap procedure please see the installation guide . After you've installed Flux v2 on your cluster using bootstrap, you can delete the Flux v1 from your clusters and move the manifests from the Flux v1 repository to the bootstrap one. In-place migration \u00b6 Warning For production use we recommend using the bootstrap procedure, but if you wish to install Flux v2 in the same way as Flux v1 then follow along. Flux read-only mode \u00b6 Assuming you've installed Flux v1 to sync a directory with plain YAMLs from a private Git repo: # create namespace kubectl create ns flux # deploy Flux v1 fluxctl install \\ --git-url = git@github.com:org/app \\ --git-branch = main \\ --git-path = ./deploy \\ --git-readonly \\ --namespace = flux | kubectl apply -f - # print deploy key fluxctl identity --k8s-fwd-ns flux # trigger sync fluxctl sync --k8s-fwd-ns flux Uninstall Flux v1 Before you proceed, scale the Flux v1 deployment to zero or delete its namespace and RBAC. If there are YAML files in your deploy dir that are not meant to be applied on the cluster, you can exclude them by placing a .sourceignore in your repo root: $ cat .sourceignore # exclude all /* # include deploy dir !/deploy # exclude files from deploy dir /deploy/**/eksctl.yaml /deploy/**/charts Install Flux v2 in the flux-system namespace: $ flux install \\ --arch = amd64 \\ --network-policy = true \\ --watch-all-namespaces = true \\ --namespace = flux-systen \u271a generating manifests \u2714 manifests build completed \u25ba installing components in flux-system namespace \u2714 install completed \u25ce verifying installation \u2714 source-controller ready \u2714 kustomize-controller ready \u2714 helm-controller ready \u2714 notification-controller ready \u2714 install finished Register your Git repository and add the deploy key with read-only access: $ flux create source git app \\ --url = ssh://git@github.com/org/app \\ --branch = main \\ --interval = 1m \u25ba generating deploy key pair ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCp2x9ghVmv1zD... Have you added the deploy key to your repository: y \u25ba collecting preferred public key from SSH server \u2714 collected public key from SSH server: github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A... \u25ba applying secret with keys \u2714 authentication configured \u271a generating GitRepository source \u25ba applying GitRepository source \u2714 GitRepository source created \u25ce waiting for GitRepository source reconciliation \u2714 GitRepository source reconciliation completed \u2714 fetched revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b Configure the reconciliation of the deploy dir on your cluster: $ flux create kustomization app \\ --source = app \\ --path = \"./deploy\" \\ --prune = true \\ --interval = 10m \u271a generating Kustomization \u25ba applying Kustomization \u2714 Kustomization created \u25ce waiting for Kustomization reconciliation \u2714 Kustomization app is ready \u2714 applied revision main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b If your repository contains secrets encrypted with Mozilla SOPS, please read this guide . Pull changes from Git and apply them immediately: flux reconcile kustomization app --with-source List all Kubernetes objects reconciled by app : kubectl get all --all-namespaces \\ -l = kustomize.toolkit.fluxcd.io/name = app \\ -l = kustomize.toolkit.fluxcd.io/namespace = flux-system Flux with Kustomize \u00b6 Assuming you've installed Flux v1 to sync a Kustomize overlay from an HTTPS Git repository: fluxctl install \\ --git-url = https://github.com/org/app \\ --git-branch = main \\ --manifest-generation \\ --namespace = flux | kubectl apply -f - With the following .flux.yaml in the root dir: version : 1 patchUpdated : generators : - command : kustomize build ./overlays/prod patchFile : flux-patch.yaml Uninstall Flux v1 Before you proceed, delete the Flux v1 namespace and remove the .flux.yaml from your repo. Install Flux v2 in the flux-system namespace: flux install Register the Git repository using a personal access token: flux create source git app \\ --url = https://github.com/org/app \\ --branch = main \\ --username = git \\ --password = token \\ --interval = 1m Configure the reconciliation of the prod overlay on your cluster: flux create kustomization app \\ --source = app \\ --path = \"./overlays/prod\" \\ --prune = true \\ --interval = 10m Check the status of the Kustomization reconciliation: $ flux get kustomizations app NAME REVISION SUSPENDED READY app main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b False True Flux with Slack notifications \u00b6 Assuming you've configured Flux v1 to send notifications to Slack with FluxCloud. With Flux v2, create an alert provider for a Slack channel: flux create alert-provider slack \\ --type = slack \\ --channel = general \\ --address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK And configure notifications for the app reconciliation events: flux create alert app \\ --provider-ref = slack \\ --event-severity = info \\ --event-source = GitRepository/app \\ --event-source = Kustomization/app For more details, read the guides on how to configure notifications and webhooks . Flux debugging \u00b6 Check the status of Git operations: $ kubectl -n flux-system get gitrepositories NAME READY MESSAGE app True Fetched revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b test False SSH handshake failed: unable to authenticate, attempted methods [none publickey] Check the status of the cluster reconciliation with kubectl: $ kubectl -n flux-system get kustomizations NAME READY STATUS app True Applied revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9 test False The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress' Suspend a reconciliation: $ flux suspend kustomization app \u25ba suspending kustomization app in flux-system namespace \u2714 kustomization suspended Check the status with kubectl: $ kubectl -n flux-system get kustomization app NAME READY STATUS app False Kustomization is suspended, skipping reconciliation Resume a reconciliation: $ flux resume kustomization app \u25ba resuming Kustomization app in flux-system namespace \u2714 Kustomization resumed \u25ce waiting for Kustomization reconciliation \u2714 Kustomization reconciliation completed \u2714 applied revision main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b","title":"Migrate from Flux v1 to v2"},{"location":"guides/flux-v1-migration/#migrate-from-flux-v1-to-v2","text":"This guide walks you through migrating from Flux v1 to v2. Read the FAQ to find out what differences are between v1 and v2. Automated image updates The image automation feature is under development in Flux v2. Please consult the roadmap for more details.","title":"Migrate from Flux v1 to v2"},{"location":"guides/flux-v1-migration/#prerequisites","text":"You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer.","title":"Prerequisites"},{"location":"guides/flux-v1-migration/#install-flux-v2-cli","text":"With Homebrew: brew install fluxcd/tap/flux With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( flux completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS, Windows and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: flux check --pre","title":"Install Flux v2 CLI"},{"location":"guides/flux-v1-migration/#gitops-migration","text":"Flux v2 offers an installation procedure that is declarative first and disaster resilient. Using the flux bootstrap command you can install Flux on a Kubernetes cluster and configure it to manage itself from a Git repository. The Git repository created during bootstrap can be used to define the state of your fleet of Kubernetes clusters. For a detailed walk-through of the bootstrap procedure please see the installation guide . After you've installed Flux v2 on your cluster using bootstrap, you can delete the Flux v1 from your clusters and move the manifests from the Flux v1 repository to the bootstrap one.","title":"GitOps migration"},{"location":"guides/flux-v1-migration/#in-place-migration","text":"Warning For production use we recommend using the bootstrap procedure, but if you wish to install Flux v2 in the same way as Flux v1 then follow along.","title":"In-place migration"},{"location":"guides/flux-v1-migration/#flux-read-only-mode","text":"Assuming you've installed Flux v1 to sync a directory with plain YAMLs from a private Git repo: # create namespace kubectl create ns flux # deploy Flux v1 fluxctl install \\ --git-url = git@github.com:org/app \\ --git-branch = main \\ --git-path = ./deploy \\ --git-readonly \\ --namespace = flux | kubectl apply -f - # print deploy key fluxctl identity --k8s-fwd-ns flux # trigger sync fluxctl sync --k8s-fwd-ns flux Uninstall Flux v1 Before you proceed, scale the Flux v1 deployment to zero or delete its namespace and RBAC. If there are YAML files in your deploy dir that are not meant to be applied on the cluster, you can exclude them by placing a .sourceignore in your repo root: $ cat .sourceignore # exclude all /* # include deploy dir !/deploy # exclude files from deploy dir /deploy/**/eksctl.yaml /deploy/**/charts Install Flux v2 in the flux-system namespace: $ flux install \\ --arch = amd64 \\ --network-policy = true \\ --watch-all-namespaces = true \\ --namespace = flux-systen \u271a generating manifests \u2714 manifests build completed \u25ba installing components in flux-system namespace \u2714 install completed \u25ce verifying installation \u2714 source-controller ready \u2714 kustomize-controller ready \u2714 helm-controller ready \u2714 notification-controller ready \u2714 install finished Register your Git repository and add the deploy key with read-only access: $ flux create source git app \\ --url = ssh://git@github.com/org/app \\ --branch = main \\ --interval = 1m \u25ba generating deploy key pair ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCp2x9ghVmv1zD... Have you added the deploy key to your repository: y \u25ba collecting preferred public key from SSH server \u2714 collected public key from SSH server: github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A... \u25ba applying secret with keys \u2714 authentication configured \u271a generating GitRepository source \u25ba applying GitRepository source \u2714 GitRepository source created \u25ce waiting for GitRepository source reconciliation \u2714 GitRepository source reconciliation completed \u2714 fetched revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b Configure the reconciliation of the deploy dir on your cluster: $ flux create kustomization app \\ --source = app \\ --path = \"./deploy\" \\ --prune = true \\ --interval = 10m \u271a generating Kustomization \u25ba applying Kustomization \u2714 Kustomization created \u25ce waiting for Kustomization reconciliation \u2714 Kustomization app is ready \u2714 applied revision main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b If your repository contains secrets encrypted with Mozilla SOPS, please read this guide . Pull changes from Git and apply them immediately: flux reconcile kustomization app --with-source List all Kubernetes objects reconciled by app : kubectl get all --all-namespaces \\ -l = kustomize.toolkit.fluxcd.io/name = app \\ -l = kustomize.toolkit.fluxcd.io/namespace = flux-system","title":"Flux read-only mode"},{"location":"guides/flux-v1-migration/#flux-with-kustomize","text":"Assuming you've installed Flux v1 to sync a Kustomize overlay from an HTTPS Git repository: fluxctl install \\ --git-url = https://github.com/org/app \\ --git-branch = main \\ --manifest-generation \\ --namespace = flux | kubectl apply -f - With the following .flux.yaml in the root dir: version : 1 patchUpdated : generators : - command : kustomize build ./overlays/prod patchFile : flux-patch.yaml Uninstall Flux v1 Before you proceed, delete the Flux v1 namespace and remove the .flux.yaml from your repo. Install Flux v2 in the flux-system namespace: flux install Register the Git repository using a personal access token: flux create source git app \\ --url = https://github.com/org/app \\ --branch = main \\ --username = git \\ --password = token \\ --interval = 1m Configure the reconciliation of the prod overlay on your cluster: flux create kustomization app \\ --source = app \\ --path = \"./overlays/prod\" \\ --prune = true \\ --interval = 10m Check the status of the Kustomization reconciliation: $ flux get kustomizations app NAME REVISION SUSPENDED READY app main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b False True","title":"Flux with Kustomize"},{"location":"guides/flux-v1-migration/#flux-with-slack-notifications","text":"Assuming you've configured Flux v1 to send notifications to Slack with FluxCloud. With Flux v2, create an alert provider for a Slack channel: flux create alert-provider slack \\ --type = slack \\ --channel = general \\ --address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK And configure notifications for the app reconciliation events: flux create alert app \\ --provider-ref = slack \\ --event-severity = info \\ --event-source = GitRepository/app \\ --event-source = Kustomization/app For more details, read the guides on how to configure notifications and webhooks .","title":"Flux with Slack notifications"},{"location":"guides/flux-v1-migration/#flux-debugging","text":"Check the status of Git operations: $ kubectl -n flux-system get gitrepositories NAME READY MESSAGE app True Fetched revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b test False SSH handshake failed: unable to authenticate, attempted methods [none publickey] Check the status of the cluster reconciliation with kubectl: $ kubectl -n flux-system get kustomizations NAME READY STATUS app True Applied revision: main/5302d04c2ab8f0579500747efa0fe7abc72c8f9 test False The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress' Suspend a reconciliation: $ flux suspend kustomization app \u25ba suspending kustomization app in flux-system namespace \u2714 kustomization suspended Check the status with kubectl: $ kubectl -n flux-system get kustomization app NAME READY STATUS app False Kustomization is suspended, skipping reconciliation Resume a reconciliation: $ flux resume kustomization app \u25ba resuming Kustomization app in flux-system namespace \u2714 Kustomization resumed \u25ce waiting for Kustomization reconciliation \u2714 Kustomization reconciliation completed \u2714 applied revision main/5302d04c2ab8f0579500747efa0fe7abc72c8f9b","title":"Flux debugging"},{"location":"guides/helmreleases/","text":"Manage Helm Releases \u00b6 The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository , GitRepository , Bucket and HelmChart resources. The helm-controller is part of the default toolkit installation. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Define a chart source \u00b6 To be able to release a Helm chart, the source that contains the chart (either a HelmRepository , GitRepository , or Bucket ) has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating the resources in the flux-system namespace. By default, the source-controller watches for sources only in the flux-system namespace, this way cluster admins can prevent untrusted sources from being registered by users. Helm repository \u00b6 Helm repositories are the recommended source to retrieve Helm charts from, as they are lightweight in processing and make it possible to configure a semantic version selector for the chart version that should be released. They can be declared by creating a HelmRepository resource, the source-controller will fetch the Helm repository index for this resource on an interval and expose it as an artifact: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : podinfo namespace : flux-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details. Git repository \u00b6 Charts from Git repositories can be released by declaring a GitRepository , the source-controller will fetch the contents of the repository on an interval and expose it as an artifact. The source-controller can build and expose Helm charts as artifacts from the contents of the GitRepository artifact (more about this later on in the guide). There is one caveat you should be aware of: to make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. An example GitRepository : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : flux-system spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S or SSH address (the latter requiring authentication). The ref defines the checkout strategy, and is set to follow the master branch in the above example. For other strategies like tags or commits, see the GitRepository CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files. Authentication HTTP/S basic and SSH authentication can be configured for private Git repositories. See the GitRepository CRD docs for more details. Bucket \u00b6 Charts from S3 compatible storage buckets can be released by declaring a Bucket , the source-controller will fetch the contents of the bucket on an interval and expose it as an artifact. There is one caveat you should be aware of: to make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. An example Bucket : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gotk-system spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The provider , bucketName and endpoint together define what S3 compatible storage should be connected to. For more information, see the Bucket CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files. Define a Helm release \u00b6 With the chart source created, define a new HelmRelease to release the Helm chart: apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : <name|path> version : '4.0.x' sourceRef : kind : <HelmRepository|GitRepository|Bucket> name : podinfo namespace : flux-system interval : 1m values : replicaCount : 2 The chart.spec values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced source, and either fetch the chart for a HelmRepository , or build it from a GitRepository or Bucket . It will then make it available as a HelmChart artifact to be used by the helm-controller. The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository or Bucket , for example: ./charts/podinfo The relative path the chart package can be found at in the GitRepository or Bucket , for example: ./charts/podinfo-1.2.3.tgz The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is only taken into account for HelmRelease resources that reference a HelmRepository source. Advanced configuration The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details. Refer to values in ConfigMap and Secret resources \u00b6 It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. Note The targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation . Configure notifications \u00b6 The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the flux-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : flux-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default Configure webhook receivers \u00b6 When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n flux-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Receiver metadata : name : helm-podinfo namespace : flux-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n flux-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#manage-helm-releases","text":"The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository , GitRepository , Bucket and HelmChart resources. The helm-controller is part of the default toolkit installation.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide .","title":"Prerequisites"},{"location":"guides/helmreleases/#define-a-chart-source","text":"To be able to release a Helm chart, the source that contains the chart (either a HelmRepository , GitRepository , or Bucket ) has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating the resources in the flux-system namespace. By default, the source-controller watches for sources only in the flux-system namespace, this way cluster admins can prevent untrusted sources from being registered by users.","title":"Define a chart source"},{"location":"guides/helmreleases/#helm-repository","text":"Helm repositories are the recommended source to retrieve Helm charts from, as they are lightweight in processing and make it possible to configure a semantic version selector for the chart version that should be released. They can be declared by creating a HelmRepository resource, the source-controller will fetch the Helm repository index for this resource on an interval and expose it as an artifact: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : podinfo namespace : flux-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details.","title":"Helm repository"},{"location":"guides/helmreleases/#git-repository","text":"Charts from Git repositories can be released by declaring a GitRepository , the source-controller will fetch the contents of the repository on an interval and expose it as an artifact. The source-controller can build and expose Helm charts as artifacts from the contents of the GitRepository artifact (more about this later on in the guide). There is one caveat you should be aware of: to make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. An example GitRepository : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo namespace : flux-system spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S or SSH address (the latter requiring authentication). The ref defines the checkout strategy, and is set to follow the master branch in the above example. For other strategies like tags or commits, see the GitRepository CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files. Authentication HTTP/S basic and SSH authentication can be configured for private Git repositories. See the GitRepository CRD docs for more details.","title":"Git repository"},{"location":"guides/helmreleases/#bucket","text":"Charts from S3 compatible storage buckets can be released by declaring a Bucket , the source-controller will fetch the contents of the bucket on an interval and expose it as an artifact. There is one caveat you should be aware of: to make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. An example Bucket : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gotk-system spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The provider , bucketName and endpoint together define what S3 compatible storage should be connected to. For more information, see the Bucket CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files.","title":"Bucket"},{"location":"guides/helmreleases/#define-a-helm-release","text":"With the chart source created, define a new HelmRelease to release the Helm chart: apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : <name|path> version : '4.0.x' sourceRef : kind : <HelmRepository|GitRepository|Bucket> name : podinfo namespace : flux-system interval : 1m values : replicaCount : 2 The chart.spec values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced source, and either fetch the chart for a HelmRepository , or build it from a GitRepository or Bucket . It will then make it available as a HelmChart artifact to be used by the helm-controller. The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository or Bucket , for example: ./charts/podinfo The relative path the chart package can be found at in the GitRepository or Bucket , for example: ./charts/podinfo-1.2.3.tgz The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is only taken into account for HelmRelease resources that reference a HelmRepository source. Advanced configuration The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details.","title":"Define a Helm release"},{"location":"guides/helmreleases/#refer-to-values-in-configmap-and-secret-resources","text":"It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. Note The targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation .","title":"Refer to values in ConfigMap and Secret resources"},{"location":"guides/helmreleases/#configure-notifications","text":"The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the flux-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : flux-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default","title":"Configure notifications"},{"location":"guides/helmreleases/#configure-webhook-receivers","text":"When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n flux-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Receiver metadata : name : helm-podinfo namespace : flux-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n flux-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Configure webhook receivers"},{"location":"guides/installation/","text":"Installation \u00b6 This guide walks you through setting up Flux v2 (hereafter: \"Flux\") to manage one or more Kubernetes clusters. Prerequisites \u00b6 You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer. Install the Flux CLI \u00b6 With Homebrew: brew install fluxcd/tap/flux With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( flux completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS, Windows and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: flux check --pre Bootstrap \u00b6 Using the flux bootstrap command you can install Flux on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the Flux components manifests to the main branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the Flux components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: flux bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. If you wish to install a specific version, use the Flux release tag e.g. --version=v0.2.0 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 flux-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 gotk-components.yaml \u2502 \u251c\u2500\u2500 gotk-sync.yaml \u2502 \u2514\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 flux-system Change the default branch If you wish to change the branch to something else than main, create the repository manually, push a branch to origin and then use flux bootstrap <GIT-PROVIDER> --branch=your-branch . GitHub and GitHub Enterprise \u00b6 Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: flux bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: flux bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: flux bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --branch = main \\ --path = my-cluster GitLab and GitLab Enterprise \u00b6 Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: flux bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster \\ --personal To run the bootstrap for a repository using deploy keys for authentication, you have to specify the SSH hostname: flux bootstrap gitlab \\ --ssh-hostname = gitlab.com \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster Authentication When providing the --ssh-hostname , a read-only (SSH) deploy key will be added to your repository, otherwise your GitLab personal token will be used to authenticate against the HTTPS endpoint instead. Run the bootstrap for a repository owned by a GitLab group: flux bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: flux bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster Generic Git Server \u00b6 For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/flux-system Generate the Flux manifests with: flux install --version = latest \\ --arch = amd64 \\ # on ARM64/AARCH64 clusters use --arch=arm64 --export > ./my-cluster/flux-system/gotk-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from GitHub Container Registry and push them to your registry, for example: docker pull ghcr.io/fluxcd/source-controller:v0.2.0 docker tag ghcr.io/fluxcd/source-controller:v0.2.0 registry.internal/fluxcd/source-controller:v0.2.0 docker push registry.internal/fluxcd/source-controller:v0.2.0 Create the pull secret in the flux-system namespace: kubectl create ns flux-system kubectl -n flux-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: flux install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/flux-system/gotk-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add components\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/flux-system/gotk-components.yaml Verify that the controllers have started: flux check Create a GitRepository object on your cluster by specifying the SSH address of your repo: flux create source git flux-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then flux will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: flux create source git flux-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: flux create kustomization flux-system \\ --source = flux-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, generate a kustomization.yaml , commit and push the manifests to Git: flux export source git flux-system \\ > ./my-cluster/flux-system/gotk-sync.yaml flux export kustomization flux-system \\ >> ./my-cluster/flux-system/gotk-sync.yaml cd ./my-cluster/flux-system && kustomize create --autodetect git add -A && git commit -m \"add sync manifests\" && git push To upgrade the Flux components to a newer version, run the install command and commit the changes: flux install --version = latest \\ --export > ./my-cluster/flux-system/gotk-components.yaml git add -A && git commit -m \"update flux\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all Flux components including itself. Dev install \u00b6 For testing purposes you can install Flux without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : flux install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: flux create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m flux create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : flux install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: flux create source helm stable \\ --interval = 1h \\ --url = https://charts.helm.sh/stable flux create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = flux-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" Monitoring with Prometheus and Grafana \u00b6 Flux comes with a monitoring stack composed of Prometheus and Grafana. The controllers expose metrics that can be used to track the readiness of the cluster reconciliation process. To install the monitoring stack please follow this guide . Uninstall \u00b6 You can uninstall the Flux components with: flux uninstall --crds The above command will delete the custom resources definitions, the controllers, and the namespace where they were installed.","title":"Installation"},{"location":"guides/installation/#installation","text":"This guide walks you through setting up Flux v2 (hereafter: \"Flux\") to manage one or more Kubernetes clusters.","title":"Installation"},{"location":"guides/installation/#prerequisites","text":"You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer.","title":"Prerequisites"},{"location":"guides/installation/#install-the-flux-cli","text":"With Homebrew: brew install fluxcd/tap/flux With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( flux completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS, Windows and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: flux check --pre","title":"Install the Flux CLI"},{"location":"guides/installation/#bootstrap","text":"Using the flux bootstrap command you can install Flux on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the Flux components manifests to the main branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the Flux components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: flux bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. If you wish to install a specific version, use the Flux release tag e.g. --version=v0.2.0 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 flux-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 gotk-components.yaml \u2502 \u251c\u2500\u2500 gotk-sync.yaml \u2502 \u2514\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 flux-system Change the default branch If you wish to change the branch to something else than main, create the repository manually, push a branch to origin and then use flux bootstrap <GIT-PROVIDER> --branch=your-branch .","title":"Bootstrap"},{"location":"guides/installation/#github-and-github-enterprise","text":"Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: flux bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: flux bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: flux bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --branch = main \\ --path = my-cluster","title":"GitHub and GitHub Enterprise"},{"location":"guides/installation/#gitlab-and-gitlab-enterprise","text":"Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: flux bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster \\ --personal To run the bootstrap for a repository using deploy keys for authentication, you have to specify the SSH hostname: flux bootstrap gitlab \\ --ssh-hostname = gitlab.com \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster Authentication When providing the --ssh-hostname , a read-only (SSH) deploy key will be added to your repository, otherwise your GitLab personal token will be used to authenticate against the HTTPS endpoint instead. Run the bootstrap for a repository owned by a GitLab group: flux bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: flux bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster","title":"GitLab and GitLab Enterprise"},{"location":"guides/installation/#generic-git-server","text":"For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/flux-system Generate the Flux manifests with: flux install --version = latest \\ --arch = amd64 \\ # on ARM64/AARCH64 clusters use --arch=arm64 --export > ./my-cluster/flux-system/gotk-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from GitHub Container Registry and push them to your registry, for example: docker pull ghcr.io/fluxcd/source-controller:v0.2.0 docker tag ghcr.io/fluxcd/source-controller:v0.2.0 registry.internal/fluxcd/source-controller:v0.2.0 docker push registry.internal/fluxcd/source-controller:v0.2.0 Create the pull secret in the flux-system namespace: kubectl create ns flux-system kubectl -n flux-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: flux install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/flux-system/gotk-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add components\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/flux-system/gotk-components.yaml Verify that the controllers have started: flux check Create a GitRepository object on your cluster by specifying the SSH address of your repo: flux create source git flux-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then flux will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: flux create source git flux-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: flux create kustomization flux-system \\ --source = flux-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, generate a kustomization.yaml , commit and push the manifests to Git: flux export source git flux-system \\ > ./my-cluster/flux-system/gotk-sync.yaml flux export kustomization flux-system \\ >> ./my-cluster/flux-system/gotk-sync.yaml cd ./my-cluster/flux-system && kustomize create --autodetect git add -A && git commit -m \"add sync manifests\" && git push To upgrade the Flux components to a newer version, run the install command and commit the changes: flux install --version = latest \\ --export > ./my-cluster/flux-system/gotk-components.yaml git add -A && git commit -m \"update flux\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all Flux components including itself.","title":"Generic Git Server"},{"location":"guides/installation/#dev-install","text":"For testing purposes you can install Flux without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : flux install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: flux create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m flux create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : flux install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: flux create source helm stable \\ --interval = 1h \\ --url = https://charts.helm.sh/stable flux create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = flux-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\"","title":"Dev install"},{"location":"guides/installation/#monitoring-with-prometheus-and-grafana","text":"Flux comes with a monitoring stack composed of Prometheus and Grafana. The controllers expose metrics that can be used to track the readiness of the cluster reconciliation process. To install the monitoring stack please follow this guide .","title":"Monitoring with Prometheus and Grafana"},{"location":"guides/installation/#uninstall","text":"You can uninstall the Flux components with: flux uninstall --crds The above command will delete the custom resources definitions, the controllers, and the namespace where they were installed.","title":"Uninstall"},{"location":"guides/monitoring/","text":"Monitoring \u00b6 This guide walks you through configuring monitoring for the Flux control plane. Flux comes with a monitoring stack composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats Install the monitoring stack \u00b6 To install the monitoring stack with flux , first register the toolkit Git repository on your cluster: flux create source git monitoring \\ --interval = 30m \\ --url = https://github.com/fluxcd/flux2 \\ --branch = main Then apply the manifests/monitoring kustomization: flux create kustomization monitoring \\ --interval = 1h \\ --prune = true \\ --source = monitoring \\ --path = \"./manifests/monitoring\" \\ --health-check = \"Deployment/prometheus.flux-system\" \\ --health-check = \"Deployment/grafana.flux-system\" You can access Grafana using port forwarding: kubectl -n flux-system port-forward svc/grafana 3000 :3000 Grafana dashboards \u00b6 Control plane dashboard http://localhost:3000/d/gitops-toolkit-control-plane : Cluster reconciliation dashboard http://localhost:3000/d/gitops-toolkit-cluster : If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping. Metrics \u00b6 For each toolkit.fluxcd.io kind, the controllers expose a gauge metric to track the Ready condition status, and a histogram with the reconciliation duration in seconds. Ready status metrics: gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"True\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"False\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"Unkown\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"Deleted\" } Time spent reconciling: gotk_reconcile_duration_seconds_bucket{kind, name, namespace, le} gotk_reconcile_duration_seconds_sum{kind, name, namespace} gotk_reconcile_duration_seconds_count{kind, name, namespace} Alert manager example: groups : - name : GitOpsToolkit rules : - alert : ReconciliationFailure expr : gotk_reconcile_condition{type=\"Ready\",status=\"False\"} == 1 for : 10m labels : severity : page annotations : summary : '{{ $labels.kind }} {{ $labels.namespace }}/{{ $labels.name }} reconciliation has been failing for more than ten minutes.'","title":"Monitoring with Prometheus"},{"location":"guides/monitoring/#monitoring","text":"This guide walks you through configuring monitoring for the Flux control plane. Flux comes with a monitoring stack composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats","title":"Monitoring"},{"location":"guides/monitoring/#install-the-monitoring-stack","text":"To install the monitoring stack with flux , first register the toolkit Git repository on your cluster: flux create source git monitoring \\ --interval = 30m \\ --url = https://github.com/fluxcd/flux2 \\ --branch = main Then apply the manifests/monitoring kustomization: flux create kustomization monitoring \\ --interval = 1h \\ --prune = true \\ --source = monitoring \\ --path = \"./manifests/monitoring\" \\ --health-check = \"Deployment/prometheus.flux-system\" \\ --health-check = \"Deployment/grafana.flux-system\" You can access Grafana using port forwarding: kubectl -n flux-system port-forward svc/grafana 3000 :3000","title":"Install the monitoring stack"},{"location":"guides/monitoring/#grafana-dashboards","text":"Control plane dashboard http://localhost:3000/d/gitops-toolkit-control-plane : Cluster reconciliation dashboard http://localhost:3000/d/gitops-toolkit-cluster : If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping.","title":"Grafana dashboards"},{"location":"guides/monitoring/#metrics","text":"For each toolkit.fluxcd.io kind, the controllers expose a gauge metric to track the Ready condition status, and a histogram with the reconciliation duration in seconds. Ready status metrics: gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"True\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"False\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"Unkown\" } gotk_reconcile_condition { kind, name, namespace, type = \"Ready\" , status = \"Deleted\" } Time spent reconciling: gotk_reconcile_duration_seconds_bucket{kind, name, namespace, le} gotk_reconcile_duration_seconds_sum{kind, name, namespace} gotk_reconcile_duration_seconds_count{kind, name, namespace} Alert manager example: groups : - name : GitOpsToolkit rules : - alert : ReconciliationFailure expr : gotk_reconcile_condition{type=\"Ready\",status=\"False\"} == 1 for : 10m labels : severity : page annotations : summary : '{{ $labels.kind }} {{ $labels.namespace }}/{{ $labels.name }} reconciliation has been failing for more than ten minutes.'","title":"Metrics"},{"location":"guides/mozilla-sops/","text":"Manage Kubernetes secrets with Mozilla SOPS \u00b6 In order to store secrets safely in a public or private Git repository, you can use Mozilla's SOPS CLI to encrypt Kubernetes secrets with OpenPGP, AWS KMS, GCP KMS and Azure Key Vault. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Install gnupg and sops : brew install gnupg sops Generate a GPG key \u00b6 Generate a GPG key with OpenPGP without specifying a passphrase: $ gpg --full-generate-key Real name: stefanprodan Email address: stefanprodan@users.noreply.github.com Comment: You selected this USER-ID: \"stefanprodan <stefanprodan@users.noreply.github.com>\" Retrieve the GPG key ID (second row of the sec column): $ gpg --list-secret-keys stefanprodan@users.noreply.github.com sec rsa3072 2020-09-06 [SC] 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 Export the public and private keypair from your local GPG keyring and create a Kubernetes secret named sops-gpg in the flux-system namespace: gpg --export-secret-keys \\ --armor 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 | kubectl create secret generic sops-gpg \\ --namespace = flux-system \\ --from-file = sops.asc = /dev/stdin Encrypt secrets \u00b6 Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run = client \\ -o yaml > basic-auth.yaml Encrypt the secret with sops using your GPG key: sops --encrypt \\ --pgp = 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 \\ --encrypted-regex '^(data|stringData)$' \\ --in-place basic-auth.yaml Hint Note that you should encrypt only the data section. Encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. You can now commit the encrypted secret to your Git repository. Configure secrets decryption \u00b6 Registry the Git repository on your cluster: flux create source git my-secrets \\ --url = https://github.com/my-org/my-secrets Create a kustomization for reconciling the secrets on the cluster: flux create kustomization my-secrets \\ --source = my-secrets \\ --prune = true \\ --interval = 10m \\ --decryption-provider = sops \\ --decryption-secret = sops-gpg Note that the sops-gpg can contain more than one key, sops will try to decrypt the secrets by iterating over all the private keys until it finds one that works. Hint When using AWS/GCP KMS or Azure Key Vault, you'll have to bind an IAM Role with read access to the KMS keys to the default service account of the flux-system namespace for kustomize-controller to be able to fetch keys from KMS. GitOps workflow \u00b6 A cluster admin should create the Kubernetes secret with the PGP keys on each cluster and add the GitRepository/Kustomization manifests to the fleet repository. Git repository manifest: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : my-secrets namespace : flux-system spec : interval : 1m url : https://github.com/my-org/my-secrets Kustomization manifest: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets namespace : flux-system spec : interval : 10m0s sourceRef : kind : GitRepository name : my-secrets path : ./ prune : true decryption : provider : sops secretRef : name : sops-gpg Hint You can generate the above manifests using flux create <kind> --export > manifest.yaml . Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret data field with sops create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var commit the manifests db-auth.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller loads the GPG keys from the sops-pgp secret kustomize-controller decrypts the Kubernetes secrets with sops and applies them on the cluster kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"Mozilla SOPS"},{"location":"guides/mozilla-sops/#manage-kubernetes-secrets-with-mozilla-sops","text":"In order to store secrets safely in a public or private Git repository, you can use Mozilla's SOPS CLI to encrypt Kubernetes secrets with OpenPGP, AWS KMS, GCP KMS and Azure Key Vault.","title":"Manage Kubernetes secrets with Mozilla SOPS"},{"location":"guides/mozilla-sops/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Install gnupg and sops : brew install gnupg sops","title":"Prerequisites"},{"location":"guides/mozilla-sops/#generate-a-gpg-key","text":"Generate a GPG key with OpenPGP without specifying a passphrase: $ gpg --full-generate-key Real name: stefanprodan Email address: stefanprodan@users.noreply.github.com Comment: You selected this USER-ID: \"stefanprodan <stefanprodan@users.noreply.github.com>\" Retrieve the GPG key ID (second row of the sec column): $ gpg --list-secret-keys stefanprodan@users.noreply.github.com sec rsa3072 2020-09-06 [SC] 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 Export the public and private keypair from your local GPG keyring and create a Kubernetes secret named sops-gpg in the flux-system namespace: gpg --export-secret-keys \\ --armor 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 | kubectl create secret generic sops-gpg \\ --namespace = flux-system \\ --from-file = sops.asc = /dev/stdin","title":"Generate a GPG key"},{"location":"guides/mozilla-sops/#encrypt-secrets","text":"Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run = client \\ -o yaml > basic-auth.yaml Encrypt the secret with sops using your GPG key: sops --encrypt \\ --pgp = 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 \\ --encrypted-regex '^(data|stringData)$' \\ --in-place basic-auth.yaml Hint Note that you should encrypt only the data section. Encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. You can now commit the encrypted secret to your Git repository.","title":"Encrypt secrets"},{"location":"guides/mozilla-sops/#configure-secrets-decryption","text":"Registry the Git repository on your cluster: flux create source git my-secrets \\ --url = https://github.com/my-org/my-secrets Create a kustomization for reconciling the secrets on the cluster: flux create kustomization my-secrets \\ --source = my-secrets \\ --prune = true \\ --interval = 10m \\ --decryption-provider = sops \\ --decryption-secret = sops-gpg Note that the sops-gpg can contain more than one key, sops will try to decrypt the secrets by iterating over all the private keys until it finds one that works. Hint When using AWS/GCP KMS or Azure Key Vault, you'll have to bind an IAM Role with read access to the KMS keys to the default service account of the flux-system namespace for kustomize-controller to be able to fetch keys from KMS.","title":"Configure secrets decryption"},{"location":"guides/mozilla-sops/#gitops-workflow","text":"A cluster admin should create the Kubernetes secret with the PGP keys on each cluster and add the GitRepository/Kustomization manifests to the fleet repository. Git repository manifest: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : my-secrets namespace : flux-system spec : interval : 1m url : https://github.com/my-org/my-secrets Kustomization manifest: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets namespace : flux-system spec : interval : 10m0s sourceRef : kind : GitRepository name : my-secrets path : ./ prune : true decryption : provider : sops secretRef : name : sops-gpg Hint You can generate the above manifests using flux create <kind> --export > manifest.yaml . Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret data field with sops create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var commit the manifests db-auth.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller loads the GPG keys from the sops-pgp secret kustomize-controller decrypts the Kubernetes secrets with sops and applies them on the cluster kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"GitOps workflow"},{"location":"guides/notifications/","text":"Setup Notifications \u00b6 When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation. Define a provider \u00b6 First create a secret with your Slack incoming webhook: kubectl -n flux-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : flux-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket , github , gitlab or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc. Define an alert \u00b6 Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : on-call-webapp namespace : flux-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n flux-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs Git commit status \u00b6 The github and gitlab provider are slightly different to the other chat providers. These providers will link an event back to its source by writing a commit status event to the repository. For more information about how a commit status works, refer to the GitHub or GitLab documentation. The first image is an example of how it may look like in GitHub while the one below is an example for GitLab. Currently the provider will only work with Alerts for Kustomization resources as the events have to be linked with a specific git commit. Any other event that does not contain a commit reference will be ignored by the provider. Each status will contain some additional information from the event which includes the resource kind, name and reason for the event. It will be displayed in the format of {{ .Kind }}/{{ .Name }} - {{ .Reason }} . To get started the git provider require an authentication token to communicate with the API. Follow the GitHub or Gitlab for a detailed guide how to create a token. Store the generated token in a Secret with the following data format. apiVersion : v1 kind : Secret metadata : name : github namespace : gitops-system data : token : <token> Creating a git provider is very similar to creating other types of providers. The only caveat being that the provider address needs to point to the same git repository as the Kustomization resource refers to. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : flux-system spec : type : github channel : general address : https://github.com/stefanprodan/podinfo secretRef : name : github --- apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : podinfo namespace : flux-system spec : providerRef : name : podinfo eventSeverity : info eventSources : - kind : Kustomization name : podinfo namespace : flux-system The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub API. apiVersion : v1 kind : Secret metadata : name : github namespace : flux-system data : token : <token>","title":"Setup Notifications"},{"location":"guides/notifications/#setup-notifications","text":"When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy.","title":"Setup Notifications"},{"location":"guides/notifications/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/notifications/#define-a-provider","text":"First create a secret with your Slack incoming webhook: kubectl -n flux-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : flux-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket , github , gitlab or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc.","title":"Define a provider"},{"location":"guides/notifications/#define-an-alert","text":"Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : on-call-webapp namespace : flux-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n flux-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs","title":"Define an alert"},{"location":"guides/notifications/#git-commit-status","text":"The github and gitlab provider are slightly different to the other chat providers. These providers will link an event back to its source by writing a commit status event to the repository. For more information about how a commit status works, refer to the GitHub or GitLab documentation. The first image is an example of how it may look like in GitHub while the one below is an example for GitLab. Currently the provider will only work with Alerts for Kustomization resources as the events have to be linked with a specific git commit. Any other event that does not contain a commit reference will be ignored by the provider. Each status will contain some additional information from the event which includes the resource kind, name and reason for the event. It will be displayed in the format of {{ .Kind }}/{{ .Name }} - {{ .Reason }} . To get started the git provider require an authentication token to communicate with the API. Follow the GitHub or Gitlab for a detailed guide how to create a token. Store the generated token in a Secret with the following data format. apiVersion : v1 kind : Secret metadata : name : github namespace : gitops-system data : token : <token> Creating a git provider is very similar to creating other types of providers. The only caveat being that the provider address needs to point to the same git repository as the Kustomization resource refers to. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : flux-system spec : type : github channel : general address : https://github.com/stefanprodan/podinfo secretRef : name : github --- apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : podinfo namespace : flux-system spec : providerRef : name : podinfo eventSeverity : info eventSources : - kind : Kustomization name : podinfo namespace : flux-system The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub API. apiVersion : v1 kind : Secret metadata : name : github namespace : flux-system data : token : <token>","title":"Git commit status"},{"location":"guides/sealed-secrets/","text":"Sealed Secrets \u00b6 In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub . Deploy sealed-secrets with a HelmRelease \u00b6 You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: flux create source helm stable \\ --interval = 1h \\ --url = https://charts.helm.sh/stable With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: flux create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = flux-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" With chart version 1.10.x we configure helm-controller to automatically upgrade the release when a new chart patch version is fetched by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the flux-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = flux-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster. Encrypt secrets \u00b6 Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s GitOps workflow \u00b6 A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable namespace : flux-system spec : interval : 1h0m0s url : https://charts.helm.sh/stable Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : sealed-secrets namespace : flux-system spec : chart : spec : chart : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"1.10.x\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : flux-system Hint You can generate the above manifests using flux create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#sealed-secrets","text":"In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository.","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub .","title":"Prerequisites"},{"location":"guides/sealed-secrets/#deploy-sealed-secrets-with-a-helmrelease","text":"You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: flux create source helm stable \\ --interval = 1h \\ --url = https://charts.helm.sh/stable With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: flux create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = flux-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" With chart version 1.10.x we configure helm-controller to automatically upgrade the release when a new chart patch version is fetched by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the flux-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = flux-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster.","title":"Deploy sealed-secrets with a HelmRelease"},{"location":"guides/sealed-secrets/#encrypt-secrets","text":"Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s","title":"Encrypt secrets"},{"location":"guides/sealed-secrets/#gitops-workflow","text":"A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable namespace : flux-system spec : interval : 1h0m0s url : https://charts.helm.sh/stable Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : sealed-secrets namespace : flux-system spec : chart : spec : chart : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"1.10.x\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : flux-system Hint You can generate the above manifests using flux create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"GitOps workflow"},{"location":"guides/webhook-receivers/","text":"Setup Webhook Receivers \u00b6 The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation. Expose the webhook receiver \u00b6 In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : flux-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n flux-system get svc/receiver Define a Git repository \u00b6 Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : webapp namespace : flux-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details. Define a Git repository receiver \u00b6 First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n flux-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Receiver metadata : name : webapp namespace : flux-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbor and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n flux-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#setup-webhook-receivers","text":"The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events.","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/webhook-receivers/#expose-the-webhook-receiver","text":"In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : flux-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n flux-system get svc/receiver","title":"Expose the webhook receiver"},{"location":"guides/webhook-receivers/#define-a-git-repository","text":"Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : webapp namespace : flux-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details.","title":"Define a Git repository"},{"location":"guides/webhook-receivers/#define-a-git-repository-receiver","text":"First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n flux-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Receiver metadata : name : webapp namespace : flux-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbor and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n flux-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Define a Git repository receiver"},{"location":"internal/release/","text":"Flux release procedure \u00b6 The Flux Go modules and the GitOps Toolkit controllers are released by following the semver conventions. Repositories subject to semver releases: fluxcd/pkg modules: apis/meta , runtime , various utilities dependencies: k8s.io/* , sigs.k8s.io/controller-runtime fluxcd/source-controller modules: api dependencies: github.com/fluxcd/pkg/* fluxcd/kustomize-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/helm-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/notification-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/flux2 modules: manifestgen dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/kustomize-controller/api , github.com/fluxcd/helm-controller/api , github.com/fluxcd/notification-controller/api , github.com/fluxcd/pkg/* Release procedure \u00b6 Go packages \u00b6 The Go packages in fluxcd/pkg are dedicated modules, each module has its own set of dependencies and release cycle. Release procedure for a package: Checkout the main branch and pull changes from remote. Run make release-<package name> VER=<next semver> . Controllers \u00b6 A toolkit controller has a dedicated module for its API, the API module has its own set of dependencies. Release procedure for a controller and its API: Checkout the main branch and pull changes from remote. Create a api/<next semver> tag and push it to remote. Create a new branch from main i.e. release-<next semver> . This will function as your release preparation branch. Update the github.com/fluxcd/<NAME>-controller/api version in go.mod Add an entry to the CHANGELOG.md for the new release and change the newTag value in config/manager/kustomization.yaml to that of the semver release you are going to make. Commit and push your changes. Create a PR for your release branch and get it merged into main . Create a <next semver> tag for the merge commit in main and push it to remote. Confirm CI builds and releases the newly tagged version. Flux \u00b6 Release procedure for Flux: Checkout the main branch and pull changes from remote. Create a <next semver> tag form main and push it to remote. Confirm CI builds and releases the newly tagged version. Upgrade Kubernetes modules \u00b6 Flux has the following Kubernetes dependencies: k8s.io/api k8s.io/apiextensions-apiserver k8s.io/apimachinery k8s.io/cli-runtime k8s.io/client-go sigs.k8s.io/controller-runtime Note that all k8s.io/* packages must the have the same version in go.mod e.g.: k8s.io/api v0.19.2 k8s.io/apiextensions-apiserver v0.19.2 k8s.io/apimachinery v0.19.2 k8s.io/cli-runtime v0.19.2 k8s.io/client-go v0.19.2 The specialised reconcilers depend on: kustomize-controller: sigs.k8s.io/kustomize/api helm-controller: helm.sh/helm/v3 Note that the k8s.io/* version must be compatible with both kustomize/api and helm/v3 . If there is a breaking change in client-go we have to wait for Kustomize and Helm to upgrade first. Upgrade procedure: fluxcd/pkg : Update the k8s.io/* version in pkg/apis/meta/go.mod Release the apis/meta package Update apis/meta version in pkg/runtime/go.mod Update the k8s.io/* version in pkg/runtime/go.mod Update sigs.k8s.io/controller-runtime version in pkg/runtime/go.mod Release the runtime package fluxcd/source-controller : Update the github.com/fluxcd/pkg/apis/meta version in source-controller/api/go.mod and source-controller/go.mod Update the k8s.io/* version in source-controller/api/go.mod and source-controller/go.mod Update the sigs.k8s.io/controller-runtime version in source-controller/api/go.mod and source-controller/go.mod Update the github.com/fluxcd/pkg/runtime version in source-controller/go.mod Release the api package fluxcd/<kustomize|helm|notification>-controller : Update the github.com/fluxcd/source-controller/api version in controller/api/go.mod and controller/go.mod Update the github.com/fluxcd/pkg/apis/meta version in controller/api/go.mod and controller/go.mod Update the k8s.io/* version in controller/api/go.mod and controller/go.mod Update the github.com/fluxcd/pkg/runtime version in controller/go.mod Release the api package fluxcd/flux2 : Update the github.com/fluxcd/*-controller/api version in flux2/go.mod Update the github.com/fluxcd/pkg/* version in flux2/go.mod Update the k8s.io/* and github.com/fluxcd/pkg/runtime version in flux2/go.mod","title":"Flux release procedure"},{"location":"internal/release/#flux-release-procedure","text":"The Flux Go modules and the GitOps Toolkit controllers are released by following the semver conventions. Repositories subject to semver releases: fluxcd/pkg modules: apis/meta , runtime , various utilities dependencies: k8s.io/* , sigs.k8s.io/controller-runtime fluxcd/source-controller modules: api dependencies: github.com/fluxcd/pkg/* fluxcd/kustomize-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/helm-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/notification-controller modules: api dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/pkg/* fluxcd/flux2 modules: manifestgen dependencies: github.com/fluxcd/source-controller/api , github.com/fluxcd/kustomize-controller/api , github.com/fluxcd/helm-controller/api , github.com/fluxcd/notification-controller/api , github.com/fluxcd/pkg/*","title":"Flux release procedure"},{"location":"internal/release/#release-procedure","text":"","title":"Release procedure"},{"location":"internal/release/#go-packages","text":"The Go packages in fluxcd/pkg are dedicated modules, each module has its own set of dependencies and release cycle. Release procedure for a package: Checkout the main branch and pull changes from remote. Run make release-<package name> VER=<next semver> .","title":"Go packages"},{"location":"internal/release/#controllers","text":"A toolkit controller has a dedicated module for its API, the API module has its own set of dependencies. Release procedure for a controller and its API: Checkout the main branch and pull changes from remote. Create a api/<next semver> tag and push it to remote. Create a new branch from main i.e. release-<next semver> . This will function as your release preparation branch. Update the github.com/fluxcd/<NAME>-controller/api version in go.mod Add an entry to the CHANGELOG.md for the new release and change the newTag value in config/manager/kustomization.yaml to that of the semver release you are going to make. Commit and push your changes. Create a PR for your release branch and get it merged into main . Create a <next semver> tag for the merge commit in main and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Controllers"},{"location":"internal/release/#flux","text":"Release procedure for Flux: Checkout the main branch and pull changes from remote. Create a <next semver> tag form main and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Flux"},{"location":"internal/release/#upgrade-kubernetes-modules","text":"Flux has the following Kubernetes dependencies: k8s.io/api k8s.io/apiextensions-apiserver k8s.io/apimachinery k8s.io/cli-runtime k8s.io/client-go sigs.k8s.io/controller-runtime Note that all k8s.io/* packages must the have the same version in go.mod e.g.: k8s.io/api v0.19.2 k8s.io/apiextensions-apiserver v0.19.2 k8s.io/apimachinery v0.19.2 k8s.io/cli-runtime v0.19.2 k8s.io/client-go v0.19.2 The specialised reconcilers depend on: kustomize-controller: sigs.k8s.io/kustomize/api helm-controller: helm.sh/helm/v3 Note that the k8s.io/* version must be compatible with both kustomize/api and helm/v3 . If there is a breaking change in client-go we have to wait for Kustomize and Helm to upgrade first. Upgrade procedure: fluxcd/pkg : Update the k8s.io/* version in pkg/apis/meta/go.mod Release the apis/meta package Update apis/meta version in pkg/runtime/go.mod Update the k8s.io/* version in pkg/runtime/go.mod Update sigs.k8s.io/controller-runtime version in pkg/runtime/go.mod Release the runtime package fluxcd/source-controller : Update the github.com/fluxcd/pkg/apis/meta version in source-controller/api/go.mod and source-controller/go.mod Update the k8s.io/* version in source-controller/api/go.mod and source-controller/go.mod Update the sigs.k8s.io/controller-runtime version in source-controller/api/go.mod and source-controller/go.mod Update the github.com/fluxcd/pkg/runtime version in source-controller/go.mod Release the api package fluxcd/<kustomize|helm|notification>-controller : Update the github.com/fluxcd/source-controller/api version in controller/api/go.mod and controller/go.mod Update the github.com/fluxcd/pkg/apis/meta version in controller/api/go.mod and controller/go.mod Update the k8s.io/* version in controller/api/go.mod and controller/go.mod Update the github.com/fluxcd/pkg/runtime version in controller/go.mod Release the api package fluxcd/flux2 : Update the github.com/fluxcd/*-controller/api version in flux2/go.mod Update the github.com/fluxcd/pkg/* version in flux2/go.mod Update the k8s.io/* and github.com/fluxcd/pkg/runtime version in flux2/go.mod","title":"Upgrade Kubernetes modules"},{"location":"proposals/go-git-providers/","text":"go-git-providers \u00b6 Abstract \u00b6 This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains. Goals \u00b6 Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod) Non-goals \u00b6 Support for features not mentioned above Design decisions \u00b6 A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags Implementation \u00b6 Provider package \u00b6 The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" )) Client \u00b6 The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient . MultiClient \u00b6 In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) } OrganizationsClient \u00b6 The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` } OrganizationClient \u00b6 OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient } Organization Teams \u00b6 Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository. RepositoriesClient \u00b6 RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s) RepositoryClient \u00b6 RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient } Repository Teams \u00b6 RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission } Repository Credentials \u00b6 RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"go-git-providers"},{"location":"proposals/go-git-providers/#go-git-providers","text":"","title":"go-git-providers"},{"location":"proposals/go-git-providers/#abstract","text":"This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains.","title":"Abstract"},{"location":"proposals/go-git-providers/#goals","text":"Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod)","title":"Goals"},{"location":"proposals/go-git-providers/#non-goals","text":"Support for features not mentioned above","title":"Non-goals"},{"location":"proposals/go-git-providers/#design-decisions","text":"A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags","title":"Design decisions"},{"location":"proposals/go-git-providers/#implementation","text":"","title":"Implementation"},{"location":"proposals/go-git-providers/#provider-package","text":"The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" ))","title":"Provider package"},{"location":"proposals/go-git-providers/#client","text":"The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient .","title":"Client"},{"location":"proposals/go-git-providers/#multiclient","text":"In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) }","title":"MultiClient"},{"location":"proposals/go-git-providers/#organizationsclient","text":"The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` }","title":"OrganizationsClient"},{"location":"proposals/go-git-providers/#organizationclient","text":"OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient }","title":"OrganizationClient"},{"location":"proposals/go-git-providers/#organization-teams","text":"Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository.","title":"Organization Teams"},{"location":"proposals/go-git-providers/#repositoriesclient","text":"RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s)","title":"RepositoriesClient"},{"location":"proposals/go-git-providers/#repositoryclient","text":"RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient }","title":"RepositoryClient"},{"location":"proposals/go-git-providers/#repository-teams","text":"RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission }","title":"Repository Teams"},{"location":"proposals/go-git-providers/#repository-credentials","text":"RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"Repository Credentials"},{"location":"roadmap/","text":"Roadmap \u00b6 In our planning discussions we identified broad three areas of work: Feature parity with Flux v1 in read-only mode Feature parity with the image-update functionality in Flux v1 Feature parity with Helm Operator v1 All of the above will constitute \"Flux v2\". The road to Flux v2 \u00b6 Flux read-only feature parity \u00b6 100% This would be the first stepping stone: we want Flux v2 to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer a migration guide for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Create a migration guide for flux.yaml kustomize users Include support for SOPS Flux image update feature parity \u00b6 30% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the Flux CLI Create a migration guide from Flux annotations The road to Helm Operator v2 \u00b6 Helm v3 feature parity \u00b6 100% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and charts from Helm and Git repositories Non-Goals Migrate users that are using Helm v2 Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support for Helm charts from Git Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Implement support for values from Secret and ConfigMap resources Implement conditional remediation on (failed) Helm actions Implement support for Helm charts from Git Implement support for referring to an alternative chart values file Stabilize API Create a migration guide for Helm Operator users","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"In our planning discussions we identified broad three areas of work: Feature parity with Flux v1 in read-only mode Feature parity with the image-update functionality in Flux v1 Feature parity with Helm Operator v1 All of the above will constitute \"Flux v2\".","title":"Roadmap"},{"location":"roadmap/#the-road-to-flux-v2","text":"","title":"The road to Flux v2"},{"location":"roadmap/#flux-read-only-feature-parity","text":"100% This would be the first stepping stone: we want Flux v2 to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer a migration guide for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Create a migration guide for flux.yaml kustomize users Include support for SOPS","title":"Flux read-only feature parity"},{"location":"roadmap/#flux-image-update-feature-parity","text":"30% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the Flux CLI Create a migration guide from Flux annotations","title":"Flux image update feature parity"},{"location":"roadmap/#the-road-to-helm-operator-v2","text":"","title":"The road to Helm Operator v2"},{"location":"roadmap/#helm-v3-feature-parity","text":"100% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and charts from Helm and Git repositories Non-Goals Migrate users that are using Helm v2 Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support for Helm charts from Git Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Implement support for values from Secret and ConfigMap resources Implement conditional remediation on (failed) Helm actions Implement support for Helm charts from Git Implement support for referring to an alternative chart values file Stabilize API Create a migration guide for Helm Operator users","title":"Helm v3 feature parity"}]}